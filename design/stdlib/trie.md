**[ DO NOT EDIT -- GENERATED by a Makefile, on Thu Mar 14 13:06:37 MDT 2019 ]**

-----------------------------------------------------------------


Hash tries
======================

Functional maps (and sets) whose representation is "canonical", and
history independent.

Background
------------------

See this POPL 1989 paper (Section 6):

 - "Incremental computation via function caching", Pugh & Teitelbaum.
 - https://dl.acm.org/citation.cfm?id=75305
 - Public copy here: http://matthewhammer.org/courses/csci7000-s17/readings/Pugh89.pdf

By contrast, other usual functional representations of maps (AVL
Trees, Red-Black Trees) do not enjoy history independence, and are
each more complex to implement (e.g., each requires "rebalancing";
these trees never do).

Done:
----------

- (hacky) type definition; XXX: need real sum types to clean it up
- find operation
- insert operation
- remove operation
- replace operation (remove+insert via a single traversal)
- basic encoding of sets, and some set operations
- basic tests (and primitive debugging) for set operations
- write trie operations that operate over pairs of tries:
  for set union, difference and intersection.
- handle hash collisions gracefully using association list module

See [Future work](#future-work) below
--------------------------------------

Assumptions
=============

Uniform depth assumption:
------------------------------

We make a simplifying assumption, for now: All defined paths in the
trie have a uniform length, the same as the number of bits of a
hash, starting at the LSB, that we use for indexing.

- If the number is too low, our expected O(log n) bounds become
  expected O(n).

- If the number is too high, we waste constant factors for
  representing small sets/maps.

In [future work](#adaptive-path-lengths), we can make this more robust
by making this number adaptive for each path, and based on the content
of the trie along that path.

Implementation details
=======================

See below.

```
...
```

 A 2D trie is just a trie that maps dimension-1 keys to another
 layer of tries, each keyed on the dimension-2 keys.

```
...
```

   replace
   ---------
   replace the given key's value option with the given one, returning the previous one

```
...
```

   `replaceThen`
   ------------
   replace the given key's value in the trie,
   and only if successful, do the success continuation,
   otherwise, return the failure value

```
...
```

   `insert`
   ------------
   insert the given key's value in the trie; return the new trie, and the previous value associated with the key, if any

```
...
```

   `insertFresh`
   ----------------
   insert the given key's value in the trie; return the new trie; assert that no prior value is associated with the key

```
...
```

   `insertFresh2D`
   ---------------
   insert the given key's value in the trie; return the new trie;
   assert that no prior value is associated with the key

```
...
```

   `remove`
   -------------
   remove the given key's value in the trie; return the new trie

```
...
```

   `removeThen`
   ------------
   remove the given key's value in the trie,
   and only if successful, do the success continuation,
   otherwise, return the failure value

```
...
```

   `remove2D`
   --------------
   remove the given key-key pair's value in the 2D trie; return the
   new trie, and the prior value, if any.

```
...
```

   `find`
   ---------
   find the given key's value in the trie, or return null if nonexistent

```
...
```

   `merge`
   ---------
   merge tries, preferring the right trie where there are collisions
   in common keys. note: the `disj` operation generalizes this `merge`
   operation in various ways, and does not (in general) loose
   information; this operation is a simpler, special case.

```
...
```

   `mergeDisjoint`
   ----------------
   like `merge`, it merges tries, but unlike `merge`, it signals a
   dynamic error if there are collisions in common keys between the
   left and right inputs.

```
...
```

   `diff`
   ------
   The key-value pairs of the final trie consists of those pairs of
   the left trie whose keys are not present in the right trie; the
   values of the right trie are irrelevant.

```
...
```

   `disj`
   --------
   This operation generalizes the notion of "set union" to finite maps.
   Produces a "disjunctive image" of the two tries, where the values of
   matching keys are combined with the given binary operator.

   For unmatched key-value pairs, the operator is still applied to
   create the value in the image.  To accomodate these various
   situations, the operator accepts optional values, but is never
   applied to (null, null).

```
...
```

   `conj`
   ---------
   This operation generalizes the notion of "set intersection" to
   finite maps.  Produces a "conjuctive image" of the two tries, where
   the values of matching keys are combined with the given binary
   operator, and unmatched key-value pairs are not present in the output.

```
...
```

   `foldUp`
   ------------
   This operation gives a recursor for the internal structure of
   tries.  Many common operations are instantiations of this function,
   either as clients, or as hand-specialized versions (e.g., see map,
   mapFilter, exists and forAll below).

```
...
```

   `fold`
   ---------
   Fold over the key-value pairs of the trie, using an accumulator.
   The key-value pairs have no reliable or meaningful ordering.

```
...
```

   `exists`
   --------
   Test whether a given key-value pair is present, or not.

```
...
```

   `forAll`
   ---------
   Test whether all key-value pairs have a given property.

```
...
```

   `isEmpty`
   -----------
   specialized foldUp operation.
   Test for "deep emptiness": subtrees that have branching structure,
   but no leaves.  These can result from naive filtering operations;
   filter uses this function to avoid creating such subtrees.

```
...
```

   `filter`
   -----------
   filter the key-value pairs by a given predicate.

```
...
```

   `mapFilter`
   -----------
   map and filter the key-value pairs by a given partial mapping function.

```
...
```

   `equalStructure`
   ------------------

   Test for equality, but naively, based on structure.
   Does not attempt to remove "junk" in the tree;
   For instance, a "smarter" approach would equate
     `#bin{left=#empty;right=#empty}`
   with
     `#empty`.
   We do not observe that equality here.

```
...
```
Use a sum type (AST-42)


Future work
=============

Tests
---------
more regression tests for everything that is below

Variant types
------------------------
See [AST-42]() (sum types); we want this type definition instead:

 ```
 type Trie<K,V>     = { #leaf : LeafNode<K,V>; #bin : BinNode<K,V>; #empty };
 type BinNode<K,V>  = { left:Trie<K,V>; right:Trie<K,V> };
 type LeafNode<K,V> = { key:K; val:V };
 ```

Adaptive path lengths
----------------------

Currently we assume a uniform path length.  This can be inefficient,
and requires careful tuning.  In the future, we could adapt the path
length of each subtree to its cardinality; this wouild avoid
needlessly long paths, or paths that are too short for their subtree's
size.

Iterator objects
-------------------
for use in 'for ... in ...' patterns

