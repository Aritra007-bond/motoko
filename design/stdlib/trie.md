**[ DO NOT EDIT -- GENERATED by a Makefile, on Thu Mar 14 12:53:58 MDT 2019 ]**

-----------------------------------------------------------------

Use a sum type (AST-42)

Hash tries
======================

Functional maps (and sets) whose representation is "canonical", and
history independent.

Background
------------------

See this POPL 1989 paper (Section 6):

 - "Incremental computation via function caching", Pugh & Teitelbaum.
 - https://dl.acm.org/citation.cfm?id=75305
 - Public copy here: http://matthewhammer.org/courses/csci7000-s17/readings/Pugh89.pdf

By contrast, other usual functional representations of maps (AVL
Trees, Red-Black Trees) do not enjoy history independence, and are
each more complex to implement (e.g., each requires "rebalancing";
these trees never do).

Done:
----------

- (hacky) type definition; XXX: need real sum types to clean it up
- find operation
- insert operation
- remove operation
- replace operation (remove+insert via a single traversal)
- basic encoding of sets, and some set operations
- basic tests (and primitive debugging) for set operations
- write trie operations that operate over pairs of tries:
  for set union, difference and intersection.
- handle hash collisions gracefully using association list module

Assumptions
=============

Uniform depth assumption:
------------------------------

We make a simplifying assumption, for now: All defined paths in the
trie have a uniform length, the same as the number of bits of a
hash, starting at the LSB, that we use for indexing.

- If the number is too low, our expected O(log n) bounds become
  expected O(n).

- If the number is too high, we waste constant factors for
  representing small sets/maps.

In [future work](#adaptive-path-lengths), we can make this more robust
by making this number adaptive for each path, and based on the content
of the trie along that path.

Future work
=============

Tests
---------
more regression tests for everything that is below

Variant types
------------------------
See [AST-42]() (sum types); we want this type definition instead:

 ```
 type Trie<K,V>     = { #leaf : LeafNode<K,V>; #bin : BinNode<K,V>; #empty };
 type BinNode<K,V>  = { left:Trie<K,V>; right:Trie<K,V> };
 type LeafNode<K,V> = { key:K; val:V };
 ```

Adaptive path lengths
----------------------

Currently we assume a uniform path length.  This can be inefficient,
and requires careful tuning.  In the future, we could adapt the path
length of each subtree to its cardinality; this wouild avoid
needlessly long paths, or paths that are too short for their subtree's
size.

Iterator objects
-------------------
for use in 'for ... in ...' patterns

Implementation details
=======================

See below.

```
...
```

 A 2D trie is just a trie that maps dimension-1 keys to another
 layer of tries, each keyed on the dimension-2 keys.

```
...
```
```
...
```
