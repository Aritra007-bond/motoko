Temporary Wire Format
=====================

This document describes the serializaion format currently used by the
ActorScript runtime, i.e. a mapping from ActorScript types to DFINITY types (=
WebAssembly types + `databuf`, `elmembuf`, `funcref` and `actorref`), and a
mapping between the corresponding values.

This is a scaffolding tool to prototype applications until we have decided upon
the actual IDL of the system, which will change all that is described here.

It also does not support all features that we want to support eventually. In
particular, it does not support subtyping.

Some types have a *specialized argument format* when used directly as a
function arguments, rather than nested inside a data structure. All others use
the *general argument format*.

Each argument of a function is serialized separately. If the function is
defined with a list of arguments, these all become arguments of the WebAssembly
function. See the [ActorScript guide](https://hydra.oregon.dfinity.build//job/dfinity-ci-build/actorscript.pr-252/users-guide/latest/download/1/guide/#function-types) for the precise rules for function arities.


Specialized argument format: `Word32`
-------------------------------------

A message entry point with an argument of type `Word32` is directly represented
as a `I32`.

Specialized argument format: `Text`
-------------------------------------

A message entry point with an argument of type `Text` is represented as a `databuf` that contains the UTF8-encoded string.

Note that there is no terminating `\0`, and the length is implicit as the
length of the `databuf`.


General argument format
-----------------------

All other arguments are represented as a non-empty `elembuf` where

 * the first entry is a `databuf` containing the actual data (see below)
 * all further entries are the references contained in the data.

The `databuf` is generated by an in-order traversal of the data type.
All numbers are fixed-width and in little endian format.

 * A `Nat`, `Int` or `Word64` is represented by 8 bytes.
 * A `Word32` is represented by 4 bytes.
 * A `Word16` is represented by 2 bytes.
 * A `Word8` is represented by 1 byte.
 * A `Bool` is represented by 1 byte that is `0` for `false` and `1` for `true`.
 * A `Text` is represented by 4 bytes indicating the length of the following
   payload, followed by the payload as a utf8-encoded string (no trailing `\0`).
 * An `Array` is represented by 4 bytes indicating the number of entries,
   followed by the concatenation of the representation of these entries.
 * An `Tuple` is represented the concatenation of the representation of its
   entries. (No need for a length field, as it is statically determined.)
 * An `Object` is represented the concatenation of the representation of its
   fields, sorted by field name. (The field names are not serialized, as they
   are statically known.)
 * An `Option` is represented by a single byte `0` if it is `null`, or
   otherwise by a single byte `1` followed by the representation of the value
 * A reference (`actor`, `shared func`) is represented as a 32 bit number (4
   bytes) that is an index into the surrounding `elembuf`. This is never `0`, as
   the first entry in the `elembuf` is the `databuf` with the actual data.
 * An empty tuple, the type `Null` and the type `Shared` are represented by
   zero bytes.

