-- Parsing modules.as:
-- Checking modules.as:
type Stack = t<Int>
type t<T> = ?(T, t<T>)
let Collections : module {List : module {type t<T> = ?(T, t<T>); cons : <T>(T, t<T>) -> t<T>; nil : <T>() -> t<T>}}
let empty : ?(Int, t<Int>)
let push : (Int, Stack) -> Stack
-- Interpreting modules.as:
nil()
  <= null
