typechecked bank.as

 Account -> Account/3
 Bank -> Bank/1
 Issuer -> Issuer/2
 Account : Int->Account/3
 Bank : Int->Bank/1
 Issuer : ()->Issuer/2
 transfer : (Account/3,Account/3,Int)->async ()
 Bank/1 := actor{getIssuer: ()->async Issuer/2;getReserve: ()->async Account/3}
 Issuer/2 := actor{hasIssued: (like Account/3)->async Bool}
 Account/3 := actor{getBalance: ()->async Int;isCompatible: (like Account/3)->async Bool;join: Account/3->();split: Int->async Account/3}
 Account = <func>
 Bank = <func>
 Issuer = <func>
 transfer = <func>
typechecked bank_ordered.as

 Account -> Account/1
 Bank -> Bank/3
 Issuer -> Issuer/2
 Account : Int->Account/1
 Bank : Int->Bank/3
 Issuer : ()->Issuer/2
 transfer : (Account/1,Account/1,Int)->async ()
 Account/1 := actor{getBalance: ()->async Int;isCompatible: (like Account/1)->async Bool;join: Account/1->();split: Int->async Account/1}
 Issuer/2 := actor{hasIssued: (like Account/1)->async Bool}
 Bank/3 := actor{getIssuer: ()->async Issuer/2;getReserve: ()->async Account/1}
 Account = <func>
 Bank = <func>
 Issuer = <func>
 transfer = <func>
typechecked control.as

 Control -> Control/1
 Control : ()->Control/1
 Control/1 := <>actor{Loop: ()->();LoopWhile: ()->();NestedWhile: ()->();While: ()->()}
 Control = <func>
Type Error literals.as:3.18-3.25:bad literal for type Word8!
typechecked numericops.as

 TestFloat : (Float,Float)->()
 TestInt : (Int,Int)->()
 TestNat : (Nat,Nat)->()
 TestWord16 : (Word16,Word16)->()
 TestWord32 : (Word32,Word32)->()
 TestWord64 : (Word64,Word64)->()
 TestWord8 : (Word8,Word8)->()
 TestFloat = <func>
 TestInt = <func>
 TestNat = <func>
 TestWord16 = <func>
 TestWord32 = <func>
 TestWord64 = <func>
 TestWord8 = <func>
typechecked bitops.as

 TestWord16 : (Word16,Word16)->()
 TestWord32 : (Word32,Word32)->()
 TestWord64 : (Word64,Word64)->()
 TestWord8 : (Word8,Word8)->()
 TestWord16 = <func>
 TestWord32 = <func>
 TestWord64 = <func>
 TestWord8 = <func>
typechecked relationalops.as

 TestBool : (Bool,Bool)->()
 TestChar : (Char,Char)->()
 TestFloat : (Float,Float)->()
 TestInt : (Int,Int)->()
 TestNat : (Nat,Nat)->()
 TestText : (Text,Text)->()
 TestWord16 : (Word16,Word16)->()
 TestWord32 : (Word32,Word32)->()
 TestWord64 : (Word64,Word64)->()
 TestWord8 : (Word8,Word8)->()
 TestBool = <func>
 TestChar = <func>
 TestFloat = <func>
 TestInt = <func>
 TestNat = <func>
 TestText = <func>
 TestWord16 = <func>
 TestWord32 = <func>
 TestWord64 = <func>
 TestWord8 = <func>
typechecked concat.as

 TestText : (Text,Text)->()
 TestText = <func>
Type Error duplicatefield.as:4.3-4.4:duplicate field M!
Type Error nonlinearpat.as:1.5-1.14:duplicate binding for x in pattern!
typechecked typedef.as

 A -> A/12
 Arrow -> Arrow/4
 B -> B/13
 Compose -> Compose/8
 Id -> Id/9
 IntT -> IntT/1
 Seq -> Seq/11
 IntT/1 = Int
 Arrow/4 = <T/28,U/29>T/28->U/29
 Compose/8 = <T/30,U/31,V/32>(T/30->U/31)->(U/31->V/32)->T/30->V/32
 Id/9 = <T/33>T/33->T/33
 Seq/11 = <A/34>(A/34,Seq/11<A/34>?)
 A/12 = (B/13,A/12)
 B/13 = (A/12,B/13)
typechecked type_equiv.as

 A -> A/5
 T -> T/3
 A : <t/26>()->A/5<t/26>
 Test0 : (T/3<Int,Bool>,T/3<Int,Nat>)->T/3<Int,Word8>
 Test1 : (<t/27>t/27->t/27,<u/28>u/28->u/28)-><c/29>c/29->c/29
 Test2 : (<t/30,u/31>t/30->u/31,<t/32,u/33>t/32->u/33)-><t/34,u/35>t/34->u/35
 Test3 : (A/5<Int>,A/5<Int>)->A/5<Int>
 Test4 : <t/36>(A/5<t/36>,A/5<t/36>)->A/5<t/36>
 Test5 : <t/37>(A/5<T/3<t/37,Int>>,A/5<T/3<t/37,Bool>>)->A/5<T/3<t/37,Word8>>
 Test6 : <t/38>(A/5<T/3<t/38,Int>>,A/5<T/3<t/38,Bool>>)->A/5<T/3<t/38,Word8>>
 T/3 = <a/24,b/25>a/24
 A/5 := <t/26>actor{}
 A = <func>
 Test0 = <func>
 Test1 = <func>
 Test2 = <func>
 Test3 = <func>
 Test4 = <func>
 Test5 = <func>
 Test6 = <func>
typechecked quicksort.as

 QS -> QS/4
 array -> array/2
 QS : <T/11>((T/11,T/11)->Int)->QS/4<T/11>
 a :  var Int[]
 cmpi : (Int,Int)->Int
 qs : QS/4<Int>
 u : ()
 array/2 = <t/10> var t/10[]
 QS/4 := <T/11>{quicksort: (array/2<T/11>,Int,Int)->()}
quicksort(([8;3;9;5;2],0,4))
partition(([8;3;9;5;2],0,4))
trace([8;3;9;5;2])
trace([8;3;9;5;2])<-()
cmpi((8,8))
cmpi((8,8))<-0
cmpi((2,8))
cmpi((2,8))<--6
swap(([8;3;9;5;2],0,4))
swap(([2;3;9;5;8],0,4))<-()
cmpi((3,8))
cmpi((3,8))<--5
cmpi((9,8))
cmpi((9,8))<-1
cmpi((5,8))
cmpi((5,8))<--3
swap(([2;3;9;5;8],2,3))
swap(([2;3;5;9;8],2,3))<-()
cmpi((9,8))
cmpi((9,8))<-1
cmpi((5,8))
cmpi((5,8))<--3
partition(([2;3;5;9;8],0,4))<-2
quicksort(([2;3;5;9;8],0,2))
partition(([2;3;5;9;8],0,2))
trace([2;3;5;9;8])
trace([2;3;5;9;8])<-()
cmpi((2,2))
cmpi((2,2))<-0
cmpi((5,2))
cmpi((5,2))<-3
cmpi((3,2))
cmpi((3,2))<-1
cmpi((2,2))
cmpi((2,2))<-0
partition(([2;3;5;9;8],0,2))<-0
quicksort(([2;3;5;9;8],0,0))
quicksort(([2;3;5;9;8],0,0))<-()
quicksort(([2;3;5;9;8],1,2))
partition(([2;3;5;9;8],1,2))
trace([2;3;5;9;8])
trace([2;3;5;9;8])<-()
cmpi((3,3))
cmpi((3,3))<-0
cmpi((5,3))
cmpi((5,3))<-2
cmpi((3,3))
cmpi((3,3))<-0
partition(([2;3;5;9;8],1,2))<-1
quicksort(([2;3;5;9;8],1,1))
quicksort(([2;3;5;9;8],1,1))<-()
quicksort(([2;3;5;9;8],2,2))
quicksort(([2;3;5;9;8],2,2))<-()
quicksort(([2;3;5;9;8],1,2))<-()
quicksort(([2;3;5;9;8],0,2))<-()
quicksort(([2;3;5;9;8],3,4))
partition(([2;3;5;9;8],3,4))
trace([2;3;5;9;8])
trace([2;3;5;9;8])<-()
cmpi((9,9))
cmpi((9,9))<-0
cmpi((8,9))
cmpi((8,9))<--1
swap(([2;3;5;9;8],3,4))
swap(([2;3;5;8;9],3,4))<-()
cmpi((9,9))
cmpi((9,9))<-0
cmpi((8,9))
cmpi((8,9))<--1
partition(([2;3;5;8;9],3,4))<-3
quicksort(([2;3;5;8;9],3,3))
quicksort(([2;3;5;8;9],3,3))<-()
quicksort(([2;3;5;8;9],4,4))
quicksort(([2;3;5;8;9],4,4))<-()
quicksort(([2;3;5;8;9],3,4))<-()
quicksort(([2;3;5;8;9],0,4))<-()
 QS = <func>
 a =  var [2;3;5;8;9]
 cmpi = <func>
 qs = QS/4<Int>
 u = ()
typechecked hoare.as

 a :  var Int[]
 partition : ( var Int[],Int,Int)->Int
 quicksort : ( var Int[],Int,Int)->()
 swap : ( var Int[],Int,Int)->()
 x : ()
quicksort(([8;3;9;5;2],0,4))
partition(([8;3;9;5;2],0,4))
swap(([8;3;9;5;2],0,4))
swap(([2;3;9;5;8],0,4))<-()
swap(([2;3;9;5;8],2,3))
swap(([2;3;5;9;8],2,3))<-()
partition(([2;3;5;9;8],0,4))<-2
quicksort(([2;3;5;9;8],0,2))
partition(([2;3;5;9;8],0,2))
partition(([2;3;5;9;8],0,2))<-0
quicksort(([2;3;5;9;8],0,0))
quicksort(([2;3;5;9;8],0,0))<-()
quicksort(([2;3;5;9;8],1,2))
partition(([2;3;5;9;8],1,2))
partition(([2;3;5;9;8],1,2))<-1
quicksort(([2;3;5;9;8],1,1))
quicksort(([2;3;5;9;8],1,1))<-()
quicksort(([2;3;5;9;8],2,2))
quicksort(([2;3;5;9;8],2,2))<-()
quicksort(([2;3;5;9;8],1,2))<-()
quicksort(([2;3;5;9;8],0,2))<-()
quicksort(([2;3;5;9;8],3,4))
partition(([2;3;5;9;8],3,4))
swap(([2;3;5;9;8],3,4))
swap(([2;3;5;8;9],3,4))<-()
partition(([2;3;5;8;9],3,4))<-3
quicksort(([2;3;5;8;9],3,3))
quicksort(([2;3;5;8;9],3,3))<-()
quicksort(([2;3;5;8;9],4,4))
quicksort(([2;3;5;8;9],4,4))<-()
quicksort(([2;3;5;8;9],3,4))<-()
quicksort(([2;3;5;8;9],0,4))<-()
 a =  var [2;3;5;8;9]
 partition = <func>
 quicksort = <func>
 swap = <func>
 x = ()
typechecked bankex.as

 Account -> Account/3
 Bank -> Bank/1
 Issuer -> Issuer/2
 Account : Int->Account/3
 Bank : Int->Bank/1
 Issuer : ()->Issuer/2
 b : Bank/1
 main : async (Account/3,Account/3)
 show : (Text,Account/3)->()
 test : ()->async (Account/3,Account/3)
 transfer : (Account/3,Account/3,Int)->async ()
 Bank/1 := actor{getIssuer: ()->async Issuer/2;getReserve: ()->async Account/3}
 Issuer/2 := actor{hasIssued: (like Account/3)->async Bool}
 Account/3 := actor{getBalance: ()->async Int;isCompatible: (like Account/3)->async Bool;join: Account/3->();split: Int->async Account/3}
test(())
test(())<-<async>
getReserve(())
getReserve(())<-<async>
split(10)
split(10)<-<async>
split(10)
split(10)<-<async>
show((reserve,{balance=Rec (Some (Var (80))) ;credit=Rec (Some (<func>)) ;getBalance=Rec (Some (<func>)) ;isCompatible=Rec (Some (<func>)) ;join=Rec (Some (<func>)) ;split=Rec (Some (<func>)) }))
show((reserve,{balance=Rec (Some (Var (80))) ;credit=Rec (Some (<func>)) ;getBalance=Rec (Some (<func>)) ;isCompatible=Rec (Some (<func>)) ;join=Rec (Some (<func>)) ;split=Rec (Some (<func>)) }))<-()
show((a1,{balance=Rec (Some (Var (10))) ;credit=Rec (Some (<func>)) ;getBalance=Rec (Some (<func>)) ;isCompatible=Rec (Some (<func>)) ;join=Rec (Some (<func>)) ;split=Rec (Some (<func>)) }))
show((a1,{balance=Rec (Some (Var (10))) ;credit=Rec (Some (<func>)) ;getBalance=Rec (Some (<func>)) ;isCompatible=Rec (Some (<func>)) ;join=Rec (Some (<func>)) ;split=Rec (Some (<func>)) }))<-()
show((a2,{balance=Rec (Some (Var (10))) ;credit=Rec (Some (<func>)) ;getBalance=Rec (Some (<func>)) ;isCompatible=Rec (Some (<func>)) ;join=Rec (Some (<func>)) ;split=Rec (Some (<func>)) }))
show((a2,{balance=Rec (Some (Var (10))) ;credit=Rec (Some (<func>)) ;getBalance=Rec (Some (<func>)) ;isCompatible=Rec (Some (<func>)) ;join=Rec (Some (<func>)) ;split=Rec (Some (<func>)) }))<-()
transfer(({balance=Rec (Some (Var (10))) ;credit=Rec (Some (<func>)) ;getBalance=Rec (Some (<func>)) ;isCompatible=Rec (Some (<func>)) ;join=Rec (Some (<func>)) ;split=Rec (Some (<func>)) },{balance=Rec (Some (Var (10))) ;credit=Rec (Some (<func>)) ;getBalance=Rec (Some (<func>)) ;isCompatible=Rec (Some (<func>)) ;join=Rec (Some (<func>)) ;split=Rec (Some (<func>)) },5))
transfer(({balance=Rec (Some (Var (10))) ;credit=Rec (Some (<func>)) ;getBalance=Rec (Some (<func>)) ;isCompatible=Rec (Some (<func>)) ;join=Rec (Some (<func>)) ;split=Rec (Some (<func>)) },{balance=Rec (Some (Var (10))) ;credit=Rec (Some (<func>)) ;getBalance=Rec (Some (<func>)) ;isCompatible=Rec (Some (<func>)) ;join=Rec (Some (<func>)) ;split=Rec (Some (<func>)) },5))<-<async>
split(5)
split(5)<-<async>
join({balance=Rec (Some (Var (10))) ;credit=Rec (Some (<func>)) ;getBalance=Rec (Some (<func>)) ;isCompatible=Rec (Some (<func>)) ;join=Rec (Some (<func>)) ;split=Rec (Some (<func>)) })
credit(5)
credit(5)<-()
join({balance=Rec (Some (Var (15))) ;credit=Rec (Some (<func>)) ;getBalance=Rec (Some (<func>)) ;isCompatible=Rec (Some (<func>)) ;join=Rec (Some (<func>)) ;split=Rec (Some (<func>)) })<-()
show((reserve,{balance=Rec (Some (Var (80))) ;credit=Rec (Some (<func>)) ;getBalance=Rec (Some (<func>)) ;isCompatible=Rec (Some (<func>)) ;join=Rec (Some (<func>)) ;split=Rec (Some (<func>)) }))
show((reserve,{balance=Rec (Some (Var (80))) ;credit=Rec (Some (<func>)) ;getBalance=Rec (Some (<func>)) ;isCompatible=Rec (Some (<func>)) ;join=Rec (Some (<func>)) ;split=Rec (Some (<func>)) }))<-()
show((a1,{balance=Rec (Some (Var (5))) ;credit=Rec (Some (<func>)) ;getBalance=Rec (Some (<func>)) ;isCompatible=Rec (Some (<func>)) ;join=Rec (Some (<func>)) ;split=Rec (Some (<func>)) }))
show((a1,{balance=Rec (Some (Var (5))) ;credit=Rec (Some (<func>)) ;getBalance=Rec (Some (<func>)) ;isCompatible=Rec (Some (<func>)) ;join=Rec (Some (<func>)) ;split=Rec (Some (<func>)) }))<-()
show((a2,{balance=Rec (Some (Var (15))) ;credit=Rec (Some (<func>)) ;getBalance=Rec (Some (<func>)) ;isCompatible=Rec (Some (<func>)) ;join=Rec (Some (<func>)) ;split=Rec (Some (<func>)) }))
show((a2,{balance=Rec (Some (Var (15))) ;credit=Rec (Some (<func>)) ;getBalance=Rec (Some (<func>)) ;isCompatible=Rec (Some (<func>)) ;join=Rec (Some (<func>)) ;split=Rec (Some (<func>)) }))<-()
 Account = <func>
 Bank = <func>
 Issuer = <func>
 b = Bank/1
 main = async{(Account/3,Account/3),0}
 show = <func>
 test = <func>
 transfer = <func>
typechecked counter.as

 Counter -> Counter/1
 Counter : Int->Counter/1
 Show : Int->()
 Test : ()->()
 c : Counter/1
 Counter/1 := actor{Dec: ()->();Read: ()->async Int;c: var  Int}
Test(())
Test(())<-()
Dec(())
Show(10)
Show(10)<-()
Dec(())<-()
Dec(())
Show(9)
Show(9)<-()
Dec(())<-()
Dec(())
Show(8)
Show(8)<-()
Dec(())<-()
Dec(())
Show(7)
Show(7)<-()
Dec(())<-()
Dec(())
Show(6)
Show(6)<-()
Dec(())<-()
Dec(())
Show(5)
Show(5)<-()
Dec(())<-()
Dec(())
Show(4)
Show(4)<-()
Dec(())<-()
Dec(())
Show(3)
Show(3)<-()
Dec(())<-()
Dec(())
Show(2)
Show(2)<-()
Dec(())<-()
Dec(())
Show(1)
Show(1)<-()
Dec(())<-()
 Counter = <func>
 Show = <func>
 Test = <func>
 c = Counter/1
typechecked testwhile.as

 Test : ()->Int
 passed : Bool
Test(())
Test(())<-0
 Test = <func>
 passed = true
