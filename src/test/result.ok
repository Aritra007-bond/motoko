typechecked bank.as

 Account -> Account/3
 Bank -> Bank/1
 Issuer -> Issuer/2
 Account : Int->Account/3
 Bank : Int->Bank/1
 Issuer : ()->Issuer/2
 transfer : (Account/3,Account/3,Int)->async ()
 Bank/1 := <>actor{getIssuer: ()->async Issuer/2;getReserve: ()->async Account/3}
 Issuer/2 := <>actor{hasIssued: (like Account/3)->async Bool}
 Account/3 := <>actor{getBalance: ()->async Int;isCompatible: (like Account/3)->async Bool;join: Account/3->();split: Int->async Account/3}
 Account = <func>
 Bank = <func>
 Issuer = <func>
 transfer = <func>
typechecked bank_ordered.as

 Account -> Account/1
 Bank -> Bank/3
 Issuer -> Issuer/2
 Account : Int->Account/1
 Bank : Int->Bank/3
 Issuer : ()->Issuer/2
 transfer : (Account/1,Account/1,Int)->async ()
 Account/1 := <>actor{getBalance: ()->async Int;isCompatible: (like Account/1)->async Bool;join: Account/1->();split: Int->async Account/1}
 Issuer/2 := <>actor{hasIssued: (like Account/1)->async Bool}
 Bank/3 := <>actor{getIssuer: ()->async Issuer/2;getReserve: ()->async Account/1}
 Account = <func>
 Bank = <func>
 Issuer = <func>
 transfer = <func>
typechecked control.as

 Control -> Control/1
 Control : ()->Control/1
 Control/1 := <>actor{Loop: ()->();LoopWhile: ()->();NestedWhile: ()->();Test: ()->Bool;While: ()->()}
 Control = <func>
Type Error literals.as:3.18-3.25:bad literal for type Word8!
typechecked numericops.as

 TestFloat : (Float,Float)->()
 TestInt : (Int,Int)->()
 TestNat : (Nat,Nat)->()
 TestWord16 : (Word16,Word16)->()
 TestWord32 : (Word32,Word32)->()
 TestWord64 : (Word64,Word64)->()
 TestWord8 : (Word8,Word8)->()
 TestFloat = <func>
 TestInt = <func>
 TestNat = <func>
 TestWord16 = <func>
 TestWord32 = <func>
 TestWord64 = <func>
 TestWord8 = <func>
typechecked bitops.as

 TestWord16 : (Word16,Word16)->()
 TestWord32 : (Word32,Word32)->()
 TestWord64 : (Word64,Word64)->()
 TestWord8 : (Word8,Word8)->()
 TestWord16 = <func>
 TestWord32 = <func>
 TestWord64 = <func>
 TestWord8 = <func>
typechecked relationalops.as

 TestBool : (Bool,Bool)->()
 TestChar : (Char,Char)->()
 TestFloat : (Float,Float)->()
 TestInt : (Int,Int)->()
 TestNat : (Nat,Nat)->()
 TestText : (Text,Text)->()
 TestWord16 : (Word16,Word16)->()
 TestWord32 : (Word32,Word32)->()
 TestWord64 : (Word64,Word64)->()
 TestWord8 : (Word8,Word8)->()
 TestBool = <func>
 TestChar = <func>
 TestFloat = <func>
 TestInt = <func>
 TestNat = <func>
 TestText = <func>
 TestWord16 = <func>
 TestWord32 = <func>
 TestWord64 = <func>
 TestWord8 = <func>
typechecked concat.as

 TestText : (Text,Text)->()
 TestText = <func>
Type Error duplicatefield.as:4.3-4.4:duplicate field M!
Type Error nonlinearpat.as:1.5-1.14:duplicate binding for x in pattern!
typechecked typedef.as

 A -> A/12
 Arrow -> Arrow/4
 B -> B/13
 Compose -> Compose/8
 Id -> Id/9
 IntT -> IntT/1
 Seq -> Seq/11
 IntT/1 = <>Int
 Arrow/4 = <T/28,U/29>T/28->U/29
 Compose/8 = <T/30,U/31,V/32>(T/30->U/31)->(U/31->V/32)->T/30->V/32
 Id/9 = <><T/33>T/33->T/33
 Seq/11 = <A/34>(A/34,Seq/11<A/34>?)
 A/12 = <>(B/13,A/12)
 B/13 = <>(A/12,B/13)
typechecked type_equiv.as

 A -> A/5
 T -> T/3
 A : <t/14>()->A/5<t/14>
 Test0 : (T/3<Int,Bool>,T/3<Int,Nat>)->T/3<Int,Word8>
 Test1 : (<t/15>t/15->t/15,<u/16>u/16->u/16)-><c/17>c/17->c/17
 Test2 : (<t/18,u/19>t/18->u/19,<t/20,u/21>t/20->u/21)-><t/22,u/23>t/22->u/23
 Test3 : (A/5<Int>,A/5<Int>)->A/5<Int>
 Test4 : <t/24>(A/5<t/24>,A/5<t/24>)->A/5<t/24>
 Test5 : <t/25>(A/5<T/3<t/25,Int>>,A/5<T/3<t/25,Bool>>)->A/5<T/3<t/25,Word8>>
 Test6 : <t/26>(A/5<T/3<t/26,Int>>,A/5<T/3<t/26,Bool>>)->A/5<T/3<t/26,Word8>>
 T/3 = <a/12,b/13>a/12
 A/5 := <t/14>actor{}
 A = <func>
 Test0 = <func>
 Test1 = <func>
 Test2 = <func>
 Test3 = <func>
 Test4 = <func>
 Test5 = <func>
 Test6 = <func>
typechecked quicksort.as

 QS -> QS/4
 array -> array/2
 QS : <T/10>((T/10,T/10)->Int)->QS/4<T/10>
 array/2 = <t/9> var t/9[]
 QS/4 := <T/10>actor{quicksort: (array/2<T/10>,Int,Int)->()}
 QS = <func>
typechecked hoare.as

 a :  var Int[]
 partition : ( var Int[],Int,Int)->Int
 quicksort : ( var Int[],Int,Int)->()
 swap : ( var Int[],Int,Int)->()
 x : ()
quicksort(([8;3;9;5;2],0,4))
partition(([8;3;9;5;2],0,4))
swap(([8;3;9;5;2],0,4)) -> ()
swap(([2;3;9;5;8],2,3)) -> () -> 2
quicksort(([2;3;5;9;8],0,2))
partition(([2;3;5;9;8],0,2)) -> 0
quicksort(([2;3;5;9;8],0,0)) -> ()
quicksort(([2;3;5;9;8],1,2))
partition(([2;3;5;9;8],1,2)) -> 1
quicksort(([2;3;5;9;8],1,1)) -> ()
quicksort(([2;3;5;9;8],2,2)) -> () -> () -> ()
quicksort(([2;3;5;9;8],3,4))
partition(([2;3;5;9;8],3,4))
swap(([2;3;5;9;8],3,4)) -> () -> 3
quicksort(([2;3;5;8;9],3,3)) -> ()
quicksort(([2;3;5;8;9],4,4)) -> () -> () -> ()
 a =  var [2;3;5;8;9]
 partition = <func>
 quicksort = <func>
 swap = <func>
 x = ()
