-- Checking bank.as:
type Account <: actor {getBalance : () -> async Int; isCompatible : (like Account) -> async Bool; join : Account -> (); split : Int -> async Account}
type Bank <: actor {getIssuer : () -> async Issuer; getReserve : () -> async Account}
type Issuer <: actor {hasIssued : (like Account) -> async Bool}
let Account : Int -> Account
let Bank : Int -> Bank
let Issuer : () -> Issuer
let transfer : (Account, Account, Int) -> async ()
-- Interpreting bank.as:
-- Finished bank.as:
let Account : Int -> Account = func
let Bank : Int -> Bank = func
let Issuer : () -> Issuer = func
let transfer : (Account, Account, Int) -> async () = func

-- Checking bank_ordered.as:
type Account <: actor {getBalance : () -> async Int; isCompatible : (like Account) -> async Bool; join : Account -> (); split : Int -> async Account}
type Bank <: actor {getIssuer : () -> async Issuer; getReserve : () -> async Account}
type Issuer <: actor {hasIssued : (like Account) -> async Bool}
let Account : Int -> Account
let Bank : Int -> Bank
let Issuer : () -> Issuer
let transfer : (Account, Account, Int) -> async ()
-- Interpreting bank_ordered.as:
-- Finished bank_ordered.as:
let Account : Int -> Account = func
let Bank : Int -> Bank = func
let Issuer : () -> Issuer = func
let transfer : (Account, Account, Int) -> async () = func

-- Checking control.as:
type Control <: actor {testBlock : () -> (); testLoop : () -> (); testLoopWhile : () -> (); testNestedWhile : () -> (); testWhile : () -> ()}
let Control : () -> Control
-- Interpreting control.as:
-- Finished control.as:
let Control : () -> Control = func

-- Checking literals.as:
let byte : Word8
let i : Int
let i1 : Int
let i2 : Int
let n : Nat
let s : Text
let short : Word16
let u : Char
let word : Word32
-- Interpreting literals.as:
-- Finished literals.as:
let byte : Word8 = 255
let i : Int = 0
let i1 : Int = -1
let i2 : Int = 4095
let n : Nat = 0
let s : Text = "a \t\"\u{00}bb\'bc\\de txx\\x\"\u{23442}\n"
let short : Word16 = 65535
let u : Char = "\u{a34}"
let word : Word32 = 4294967295

-- Checking numericops.as:
let testFloat : (Float, Float) -> ()
let testInt : (Int, Int) -> ()
let testNat : (Nat, Nat) -> ()
let testWord16 : (Word16, Word16) -> ()
let testWord32 : (Word32, Word32) -> ()
let testWord64 : (Word64, Word64) -> ()
let testWord8 : (Word8, Word8) -> ()
-- Interpreting numericops.as:
-- Finished numericops.as:
let testFloat : (Float, Float) -> () = func
let testInt : (Int, Int) -> () = func
let testNat : (Nat, Nat) -> () = func
let testWord16 : (Word16, Word16) -> () = func
let testWord32 : (Word32, Word32) -> () = func
let testWord64 : (Word64, Word64) -> () = func
let testWord8 : (Word8, Word8) -> () = func

-- Checking bitops.as:
let testWord16 : (Word16, Word16) -> ()
let testWord32 : (Word32, Word32) -> ()
let testWord64 : (Word64, Word64) -> ()
let testWord8 : (Word8, Word8) -> ()
-- Interpreting bitops.as:
-- Finished bitops.as:
let testWord16 : (Word16, Word16) -> () = func
let testWord32 : (Word32, Word32) -> () = func
let testWord64 : (Word64, Word64) -> () = func
let testWord8 : (Word8, Word8) -> () = func

-- Checking relationalops.as:
let testBool : (Bool, Bool) -> ()
let testChar : (Char, Char) -> ()
let testFloat : (Float, Float) -> ()
let testInt : (Int, Int) -> ()
let testNat : (Nat, Nat) -> ()
let testText : (Text, Text) -> ()
let testWord16 : (Word16, Word16) -> ()
let testWord32 : (Word32, Word32) -> ()
let testWord64 : (Word64, Word64) -> ()
let testWord8 : (Word8, Word8) -> ()
-- Interpreting relationalops.as:
-- Finished relationalops.as:
let testBool : (Bool, Bool) -> () = func
let testChar : (Char, Char) -> () = func
let testFloat : (Float, Float) -> () = func
let testInt : (Int, Int) -> () = func
let testNat : (Nat, Nat) -> () = func
let testText : (Text, Text) -> () = func
let testWord16 : (Word16, Word16) -> () = func
let testWord32 : (Word32, Word32) -> () = func
let testWord64 : (Word64, Word64) -> () = func
let testWord8 : (Word8, Word8) -> () = func

-- Checking concat.as:
let testText : (Text, Text) -> ()
-- Interpreting concat.as:
-- Finished concat.as:
let testText : (Text, Text) -> () = func

-- Checking duplicatefield.as:
duplicatefield.as:4.3-4.4: type error, duplicate field name m in object

-- Checking nonlinearpat.as:
nonlinearpat.as:1.11-1.12: type error, duplicate binding for x in block

-- Checking typedef.as:
type A/1 = (B, A/1)
type Arrow<T/2, U/2> = T/2 -> U/2
type B = (A/1, B)
type Compose<T/3, U/3, V/1> = (T/3 -> U/3) -> (U/3 -> V/1) -> T/3 -> V/1
type Id = <T/4>T/4 -> T/4
type IntT = Int
type Seq<A/2> = (A/2, Seq<A/2>?)
-- Interpreting typedef.as:
-- Finished typedef.as:

-- Checking type_equiv.as:
-- Interpreting type_equiv.as:
-- Finished type_equiv.as:

-- Checking quicksort.as:
type QS<T/1> <: {quicksort : (var T/1[], Nat, Nat) -> ()}
let QS : <T/5>((T/5, T/5) -> Int) -> QS<T/5>
let a : var Int[]
let cmpi : (Int, Int) -> Int
let qs : QS<Int>
-- Interpreting quicksort.as:
QS(func)
QS(func) => {partition = func; quicksort = func; swap = func; trace = func}
quicksort([8, 3, 9, 5, 2], 0, 4)
  partition([8, 3, 9, 5, 2], 0, 4)
    trace([8, 3, 9, 5, 2])
    trace([8, 3, 9, 5, 2]) => ()
    cmpi(8, 8)
    cmpi(8, 8) => 0
    cmpi(2, 8)
    cmpi(2, 8) => -6
    swap([8, 3, 9, 5, 2], 0, 4)
    swap([2, 3, 9, 5, 8], 0, 4) => ()
    cmpi(2, 8)
    cmpi(2, 8) => -6
    cmpi(3, 8)
    cmpi(3, 8) => -5
    cmpi(9, 8)
    cmpi(9, 8) => 1
    cmpi(8, 8)
    cmpi(8, 8) => 0
    swap([2, 3, 9, 5, 8], 2, 4)
    swap([2, 3, 8, 5, 9], 2, 4) => ()
    cmpi(8, 8)
    cmpi(8, 8) => 0
    cmpi(9, 8)
    cmpi(9, 8) => 1
    cmpi(5, 8)
    cmpi(5, 8) => -3
    swap([2, 3, 8, 5, 9], 2, 3)
    swap([2, 3, 5, 8, 9], 2, 3) => ()
    cmpi(5, 8)
    cmpi(5, 8) => -3
    cmpi(8, 8)
    cmpi(8, 8) => 0
    cmpi(8, 8)
    cmpi(8, 8) => 0
  partition([2, 3, 5, 8, 9], 0, 4) => 3
  quicksort([2, 3, 5, 8, 9], 0, 3)
    partition([2, 3, 5, 8, 9], 0, 3)
      trace([2, 3, 5, 8, 9])
      trace([2, 3, 5, 8, 9]) => ()
      cmpi(2, 2)
      cmpi(2, 2) => 0
      cmpi(8, 2)
      cmpi(8, 2) => 6
      cmpi(5, 2)
      cmpi(5, 2) => 3
      cmpi(3, 2)
      cmpi(3, 2) => 1
      cmpi(2, 2)
      cmpi(2, 2) => 0
    partition([2, 3, 5, 8, 9], 0, 3) => 0
    quicksort([2, 3, 5, 8, 9], 0, 0)
    quicksort([2, 3, 5, 8, 9], 0, 0) => ()
    quicksort([2, 3, 5, 8, 9], 1, 3)
      partition([2, 3, 5, 8, 9], 1, 3)
        trace([2, 3, 5, 8, 9])
        trace([2, 3, 5, 8, 9]) => ()
        cmpi(3, 3)
        cmpi(3, 3) => 0
        cmpi(8, 3)
        cmpi(8, 3) => 5
        cmpi(5, 3)
        cmpi(5, 3) => 2
        cmpi(3, 3)
        cmpi(3, 3) => 0
      partition([2, 3, 5, 8, 9], 1, 3) => 1
      quicksort([2, 3, 5, 8, 9], 1, 1)
      quicksort([2, 3, 5, 8, 9], 1, 1) => ()
      quicksort([2, 3, 5, 8, 9], 2, 3)
        partition([2, 3, 5, 8, 9], 2, 3)
          trace([2, 3, 5, 8, 9])
          trace([2, 3, 5, 8, 9]) => ()
          cmpi(5, 5)
          cmpi(5, 5) => 0
          cmpi(8, 5)
          cmpi(8, 5) => 3
          cmpi(5, 5)
          cmpi(5, 5) => 0
        partition([2, 3, 5, 8, 9], 2, 3) => 2
        quicksort([2, 3, 5, 8, 9], 2, 2)
        quicksort([2, 3, 5, 8, 9], 2, 2) => ()
        quicksort([2, 3, 5, 8, 9], 3, 3)
        quicksort([2, 3, 5, 8, 9], 3, 3) => ()
      quicksort([2, 3, 5, 8, 9], 2, 3) => ()
    quicksort([2, 3, 5, 8, 9], 1, 3) => ()
  quicksort([2, 3, 5, 8, 9], 0, 3) => ()
  quicksort([2, 3, 5, 8, 9], 4, 4)
  quicksort([2, 3, 5, 8, 9], 4, 4) => ()
quicksort([2, 3, 5, 8, 9], 0, 4) => ()
-- Finished quicksort.as:
let QS : <T/5>((T/5, T/5) -> Int) -> QS<T/5> = func
let a : var Int[] = [2, 3, 5, 8, 9]
let cmpi : (Int, Int) -> Int = func
let qs : QS<Int> = QS<Int>

-- Checking hoare.as:
let a : var Int[]
let partition : (var Int[], Nat, Nat) -> Nat
let quicksort : (var Int[], Nat, Nat) -> ()
let swap : (var Int[], Nat, Nat) -> ()
let x : ()
-- Interpreting hoare.as:
quicksort([8, 3, 9, 5, 2], 0, 4)
  partition([8, 3, 9, 5, 2], 0, 4)
    swap([8, 3, 9, 5, 2], 0, 4)
    swap([2, 3, 9, 5, 8], 0, 4) => ()
    swap([2, 3, 9, 5, 8], 2, 4)
    swap([2, 3, 8, 5, 9], 2, 4) => ()
    swap([2, 3, 8, 5, 9], 2, 3)
    swap([2, 3, 5, 8, 9], 2, 3) => ()
  partition([2, 3, 5, 8, 9], 0, 4) => 3
  quicksort([2, 3, 5, 8, 9], 0, 3)
    partition([2, 3, 5, 8, 9], 0, 3)
    partition([2, 3, 5, 8, 9], 0, 3) => 0
    quicksort([2, 3, 5, 8, 9], 0, 0)
    quicksort([2, 3, 5, 8, 9], 0, 0) => ()
    quicksort([2, 3, 5, 8, 9], 1, 3)
      partition([2, 3, 5, 8, 9], 1, 3)
      partition([2, 3, 5, 8, 9], 1, 3) => 1
      quicksort([2, 3, 5, 8, 9], 1, 1)
      quicksort([2, 3, 5, 8, 9], 1, 1) => ()
      quicksort([2, 3, 5, 8, 9], 2, 3)
        partition([2, 3, 5, 8, 9], 2, 3)
        partition([2, 3, 5, 8, 9], 2, 3) => 2
        quicksort([2, 3, 5, 8, 9], 2, 2)
        quicksort([2, 3, 5, 8, 9], 2, 2) => ()
        quicksort([2, 3, 5, 8, 9], 3, 3)
        quicksort([2, 3, 5, 8, 9], 3, 3) => ()
      quicksort([2, 3, 5, 8, 9], 2, 3) => ()
    quicksort([2, 3, 5, 8, 9], 1, 3) => ()
  quicksort([2, 3, 5, 8, 9], 0, 3) => ()
  quicksort([2, 3, 5, 8, 9], 4, 4)
  quicksort([2, 3, 5, 8, 9], 4, 4) => ()
quicksort([2, 3, 5, 8, 9], 0, 4) => ()
-- Finished hoare.as:
let a : var Int[] = [2, 3, 5, 8, 9]
let partition : (var Int[], Nat, Nat) -> Nat = func
let quicksort : (var Int[], Nat, Nat) -> () = func
let swap : (var Int[], Nat, Nat) -> () = func
let x : () = ()

-- Checking bankex.as:
type Account <: actor {getBalance : () -> async Int; isCompatible : (like Account) -> async Bool; join : Account -> (); split : Int -> async Account}
type Bank <: actor {getIssuer : () -> async Issuer; getReserve : () -> async Account}
type Issuer <: actor {hasIssued : (like Account) -> async Bool}
let Account : Int -> Account
let Bank : Int -> Bank
let Issuer : () -> Issuer
let b : Bank
let main : async (Account, Account)
let show : (Text, Account) -> ()
let test : () -> async (Account, Account)
let transfer : (Account, Account, Int) -> async ()
-- Interpreting bankex.as:
Bank(100)
  Issuer()
  Issuer() => {hasIssued = func}
  Account(100)
  Account(100) => {balance = 100; credit = func; getBalance = func; isCompatible = func; join = func; split = func}
Bank(100) => {getIssuer = func; getReserve = func; issuer = {hasIssued = func}; reserve = {balance = 100; credit = func; getBalance = func; isCompatible = func; join = func; split = func}}
test()
test() => async _ #0
getReserve()
getReserve() => async _ #0
split(10)
split(10) => async _ #0
Account(10)
Account(10) => {balance = 10; credit = func; getBalance = func; isCompatible = func; join = func; split = func}
split(10)
split(10) => async _ #0
Account(10)
Account(10) => {balance = 10; credit = func; getBalance = func; isCompatible = func; join = func; split = func}
show("reserve", {balance = 80; credit = func; getBalance = func; isCompatible = func; join = func; split = func})
show("reserve", {balance = 80; credit = func; getBalance = func; isCompatible = func; join = func; split = func}) => ()
show("a1", {balance = 10; credit = func; getBalance = func; isCompatible = func; join = func; split = func})
show("a1", {balance = 10; credit = func; getBalance = func; isCompatible = func; join = func; split = func}) => ()
show("a2", {balance = 10; credit = func; getBalance = func; isCompatible = func; join = func; split = func})
show("a2", {balance = 10; credit = func; getBalance = func; isCompatible = func; join = func; split = func}) => ()
transfer({balance = 10; credit = func; getBalance = func; isCompatible = func; join = func; split = func}, {balance = 10; credit = func; getBalance = func; isCompatible = func; join = func; split = func}, 5)
transfer({balance = 10; credit = func; getBalance = func; isCompatible = func; join = func; split = func}, {balance = 10; credit = func; getBalance = func; isCompatible = func; join = func; split = func}, 5) => async _ #0
split(5)
split(5) => async _ #0
Account(5)
Account(5) => {balance = 5; credit = func; getBalance = func; isCompatible = func; join = func; split = func}
join({balance = 10; credit = func; getBalance = func; isCompatible = func; join = func; split = func})
  credit(5)
  credit(5) => ()
join({balance = 15; credit = func; getBalance = func; isCompatible = func; join = func; split = func}) => ()
show("reserve", {balance = 80; credit = func; getBalance = func; isCompatible = func; join = func; split = func})
show("reserve", {balance = 80; credit = func; getBalance = func; isCompatible = func; join = func; split = func}) => ()
show("a1", {balance = 5; credit = func; getBalance = func; isCompatible = func; join = func; split = func})
show("a1", {balance = 5; credit = func; getBalance = func; isCompatible = func; join = func; split = func}) => ()
show("a2", {balance = 15; credit = func; getBalance = func; isCompatible = func; join = func; split = func})
show("a2", {balance = 15; credit = func; getBalance = func; isCompatible = func; join = func; split = func}) => ()
-- Finished bankex.as:
let Account : Int -> Account = func
let Bank : Int -> Bank = func
let Issuer : () -> Issuer = func
let b : Bank = Bank
let main : async (Account, Account) = async (Account, Account)
let show : (Text, Account) -> () = func
let test : () -> async (Account, Account) = func
let transfer : (Account, Account, Int) -> async () = func

-- Checking counter.as:
type Counter <: actor {dec : () -> (); read : () -> async Int}
let Counter : Int -> Counter
let c : Counter
let show : Int -> ()
let test : () -> ()
-- Interpreting counter.as:
Counter(10)
Counter(10) => {c = 10; dec = func; read = func}
test()
test() => ()
dec()
  show(10)
  show(10) => ()
dec() => ()
dec()
  show(9)
  show(9) => ()
dec() => ()
dec()
  show(8)
  show(8) => ()
dec() => ()
dec()
  show(7)
  show(7) => ()
dec() => ()
dec()
  show(6)
  show(6) => ()
dec() => ()
dec()
  show(5)
  show(5) => ()
dec() => ()
dec()
  show(4)
  show(4) => ()
dec() => ()
dec()
  show(3)
  show(3) => ()
dec() => ()
dec()
  show(2)
  show(2) => ()
dec() => ()
dec()
  show(1)
  show(1) => ()
dec() => ()
-- Finished counter.as:
let Counter : Int -> Counter = func
let c : Counter = Counter
let show : Int -> () = func
let test : () -> () = func

-- Checking testwhile.as:
let passed : Bool
let test : () -> Int
-- Interpreting testwhile.as:
test()
test() => 0
-- Finished testwhile.as:
let passed : Bool = true
let test : () -> Int = func

-- Checking objects.as:
type O = {self : () -> O}
let ignore : (async ()) -> ()
let o : {self : () -> O}
let oo : O
let p : {get_y : () -> Int; x : Int}
let tictac : {tac : Int -> (); tic : Int -> ()}
let tictac_actor : actor {tac : Int -> async (); tic : Int -> async ()}
let tictac_async : {tac : Int -> async (); tic : Int -> async ()}
let x : Int
let y : Int
-- Interpreting objects.as:
get_y()
get_y() => 2
self()
self() => {self = func}
tic(10)
  tac(9)
    tic(8)
      tac(7)
        tic(6)
          tac(5)
            tic(4)
              tac(3)
                tic(2)
                  tac(1)
                    tic(0)
                    tic(0) => ()
                  tac(1) => ()
                tic(2) => ()
              tac(3) => ()
            tic(4) => ()
          tac(5) => ()
        tic(6) => ()
      tac(7) => ()
    tic(8) => ()
  tac(9) => ()
tic(10) => ()
tic(10)
tic(10) => async _ #0
tac(9)
tac(9) => async _ #0
ignore(async _ #0)
ignore(async _ #0) => ()
tic(10)
tic(10) => async _ #0
tic(8)
tic(8) => async _ #0
ignore(async _ #0)
ignore(async _ #0) => ()
ignore(async _ #0)
ignore(async _ #0) => ()
tac(7)
tac(7) => async _ #0
ignore(async _ #0)
ignore(async _ #0) => ()
tac(9)
tac(9) => async _ #0
tic(6)
tic(6) => async _ #0
ignore(async _ #0)
ignore(async _ #0) => ()
ignore(async _ #0)
ignore(async _ #0) => ()
tac(5)
tac(5) => async _ #0
ignore(async _ #0)
ignore(async _ #0) => ()
tic(8)
tic(8) => async _ #0
tic(4)
tic(4) => async _ #0
ignore(async _ #0)
ignore(async _ #0) => ()
ignore(async _ #0)
ignore(async _ #0) => ()
tac(3)
tac(3) => async _ #0
ignore(async _ #0)
ignore(async _ #0) => ()
tac(7)
tac(7) => async _ #0
tic(2)
tic(2) => async _ #0
ignore(async _ #0)
ignore(async _ #0) => ()
ignore(async _ #0)
ignore(async _ #0) => ()
tac(1)
tac(1) => async _ #0
ignore(async _ #0)
ignore(async _ #0) => ()
tic(6)
tic(6) => async _ #0
tic(0)
tic(0) => async _ #0
ignore(async _ #0)
ignore(async _ #0) => ()
ignore(async _ #0)
ignore(async _ #0) => ()
tac(5)
tac(5) => async _ #0
ignore(async _ #0)
ignore(async _ #0) => ()
tic(4)
tic(4) => async _ #0
ignore(async _ #0)
ignore(async _ #0) => ()
tac(3)
tac(3) => async _ #0
ignore(async _ #0)
ignore(async _ #0) => ()
tic(2)
tic(2) => async _ #0
ignore(async _ #0)
ignore(async _ #0) => ()
tac(1)
tac(1) => async _ #0
ignore(async _ #0)
ignore(async _ #0) => ()
tic(0)
tic(0) => async _ #0
-- Finished objects.as:
let ignore : (async ()) -> () = func
let o : {self : () -> O} = {self = func}
let oo : O = {self = func}
let p : {get_y : () -> Int; x : Int} = {get_y = func; x = 3}
let tictac : {tac : Int -> (); tic : Int -> ()} = {tac = func; tic = func}
let tictac_actor : actor {tac : Int -> async (); tic : Int -> async ()} = actor {tac = func; tic = func}
let tictac_async : {tac : Int -> async (); tic : Int -> async ()} = {tac = func; tic = func}
let x : Int = 3
let y : Int = 2

-- Checking overflow.as:
-- Interpreting overflow.as:
overflow.as:17.9-17.24: execution error, arithmetic overflow

-- Checking menhirbug.as:
type A = {x : {}}
-- Interpreting menhirbug.as:
-- Finished menhirbug.as:

