

Typechecking bank.as:

 Account := Account/3
 Bank := Bank/1
 Issuer := Issuer/2
 Account : Int -> Account/3
 Bank : Int -> Bank/1
 Issuer : () -> Issuer/2
 transfer : (Account/3, Account/3, Int) -> async ()
 Bank/1 <: actor {getIssuer : () -> async Issuer/2; getReserve : () -> async Account/3}
 Issuer/2 <: actor {hasIssued : (like Account/3) -> async Bool}
 Account/3 <: actor {getBalance : () -> async Int; isCompatible : (like Account/3) -> async Bool; join : Account/3 -> (); split : Int -> async Account/3}


Interpreting bank.as (tracing function calls):


Final state bank.as:

 Account = func
 Bank = func
 Issuer = func
 transfer = func



Typechecking bank_ordered.as:

 Account := Account/1
 Bank := Bank/3
 Issuer := Issuer/2
 Account : Int -> Account/1
 Bank : Int -> Bank/3
 Issuer : () -> Issuer/2
 transfer : (Account/1, Account/1, Int) -> async ()
 Account/1 <: actor {getBalance : () -> async Int; isCompatible : (like Account/1) -> async Bool; join : Account/1 -> (); split : Int -> async Account/1}
 Issuer/2 <: actor {hasIssued : (like Account/1) -> async Bool}
 Bank/3 <: actor {getIssuer : () -> async Issuer/2; getReserve : () -> async Account/1}


Interpreting bank_ordered.as (tracing function calls):


Final state bank_ordered.as:

 Account = func
 Bank = func
 Issuer = func
 transfer = func



Typechecking control.as:

 Control := Control/1
 Control : () -> Control/1
 Control/1 <: actor {testBlock : () -> (); testLoop : () -> (); testLoopWhile : () -> (); testNestedWhile : () -> (); testWhile : () -> ()}


Interpreting control.as (tracing function calls):


Final state control.as:

 Control = func

Type Error literals.as:3.20-3.27:bad or out-of-range literal for type Word8!


Typechecking numericops.as:

 testFloat : (Float, Float) -> ()
 testInt : (Int, Int) -> ()
 testNat : (Nat, Nat) -> ()
 testWord16 : (Word16, Word16) -> ()
 testWord32 : (Word32, Word32) -> ()
 testWord64 : (Word64, Word64) -> ()
 testWord8 : (Word8, Word8) -> ()


Interpreting numericops.as (tracing function calls):


Final state numericops.as:

 testFloat = func
 testInt = func
 testNat = func
 testWord16 = func
 testWord32 = func
 testWord64 = func
 testWord8 = func



Typechecking bitops.as:

 testWord16 : (Word16, Word16) -> ()
 testWord32 : (Word32, Word32) -> ()
 testWord64 : (Word64, Word64) -> ()
 testWord8 : (Word8, Word8) -> ()


Interpreting bitops.as (tracing function calls):


Final state bitops.as:

 testWord16 = func
 testWord32 = func
 testWord64 = func
 testWord8 = func



Typechecking relationalops.as:

 testBool : (Bool, Bool) -> ()
 testChar : (Char, Char) -> ()
 testFloat : (Float, Float) -> ()
 testInt : (Int, Int) -> ()
 testNat : (Nat, Nat) -> ()
 testText : (Text, Text) -> ()
 testWord16 : (Word16, Word16) -> ()
 testWord32 : (Word32, Word32) -> ()
 testWord64 : (Word64, Word64) -> ()
 testWord8 : (Word8, Word8) -> ()


Interpreting relationalops.as (tracing function calls):


Final state relationalops.as:

 testBool = func
 testChar = func
 testFloat = func
 testInt = func
 testNat = func
 testText = func
 testWord16 = func
 testWord32 = func
 testWord64 = func
 testWord8 = func



Typechecking concat.as:

 testText : (Text, Text) -> ()


Interpreting concat.as (tracing function calls):


Final state concat.as:

 testText = func

Type Error duplicatefield.as:4.3-4.4:duplicate field m!
Type Error nonlinearpat.as:1.5-1.14:duplicate binding for x in pattern!


Typechecking typedef.as:

 A := A/12
 Arrow := Arrow/4
 B := B/13
 Compose := Compose/8
 Id := Id/9
 IntT := IntT/1
 Seq := Seq/11
 IntT/1 = Int
 Arrow/4 = <T/28, U/29> T/28 -> U/29
 Compose/8 = <T/30, U/31, V/32> (T/30 -> U/31) -> (U/31 -> V/32) -> T/30 -> V/32
 Id/9 = <T/33> T/33 -> T/33
 Seq/11 = <A/34> (A/34, Seq/11<A/34>?)
 A/12 = (B/13, A/12)
 B/13 = (A/12, B/13)


Interpreting typedef.as (tracing function calls):


Final state typedef.as:




Typechecking type_equiv.as:



Interpreting type_equiv.as (tracing function calls):


Final state type_equiv.as:




Typechecking quicksort.as:

 QS := QS/4
 array := array/2
 QS : <T/11> ((T/11, T/11) -> Int) -> QS/4<T/11>
 a : var Int[]
 cmpi : (Int, Int) -> Int
 qs : QS/4<Int>
 array/2 = <t/10> var t/10[]
 QS/4 <: <T/11> {quicksort : (array/2<T/11>, Int, Int) -> ()}


Interpreting quicksort.as (tracing function calls):

quicksort([8, 3, 9, 5, 2], 0, 4)
partition([8, 3, 9, 5, 2], 0, 4)
trace([8, 3, 9, 5, 2])
trace([8, 3, 9, 5, 2]) => ()
cmpi(8, 8)
cmpi(8, 8) => 0
cmpi(2, 8)
cmpi(2, 8) => -6
swap([8, 3, 9, 5, 2], 0, 4)
swap([2, 3, 9, 5, 8], 0, 4) => ()
cmpi(3, 8)
cmpi(3, 8) => -5
cmpi(9, 8)
cmpi(9, 8) => 1
cmpi(5, 8)
cmpi(5, 8) => -3
swap([2, 3, 9, 5, 8], 2, 3)
swap([2, 3, 5, 9, 8], 2, 3) => ()
cmpi(9, 8)
cmpi(9, 8) => 1
cmpi(5, 8)
cmpi(5, 8) => -3
partition([2, 3, 5, 9, 8], 0, 4) => 2
quicksort([2, 3, 5, 9, 8], 0, 2)
partition([2, 3, 5, 9, 8], 0, 2)
trace([2, 3, 5, 9, 8])
trace([2, 3, 5, 9, 8]) => ()
cmpi(2, 2)
cmpi(2, 2) => 0
cmpi(5, 2)
cmpi(5, 2) => 3
cmpi(3, 2)
cmpi(3, 2) => 1
cmpi(2, 2)
cmpi(2, 2) => 0
partition([2, 3, 5, 9, 8], 0, 2) => 0
quicksort([2, 3, 5, 9, 8], 0, 0)
quicksort([2, 3, 5, 9, 8], 0, 0) => ()
quicksort([2, 3, 5, 9, 8], 1, 2)
partition([2, 3, 5, 9, 8], 1, 2)
trace([2, 3, 5, 9, 8])
trace([2, 3, 5, 9, 8]) => ()
cmpi(3, 3)
cmpi(3, 3) => 0
cmpi(5, 3)
cmpi(5, 3) => 2
cmpi(3, 3)
cmpi(3, 3) => 0
partition([2, 3, 5, 9, 8], 1, 2) => 1
quicksort([2, 3, 5, 9, 8], 1, 1)
quicksort([2, 3, 5, 9, 8], 1, 1) => ()
quicksort([2, 3, 5, 9, 8], 2, 2)
quicksort([2, 3, 5, 9, 8], 2, 2) => ()
quicksort([2, 3, 5, 9, 8], 1, 2) => ()
quicksort([2, 3, 5, 9, 8], 0, 2) => ()
quicksort([2, 3, 5, 9, 8], 3, 4)
partition([2, 3, 5, 9, 8], 3, 4)
trace([2, 3, 5, 9, 8])
trace([2, 3, 5, 9, 8]) => ()
cmpi(9, 9)
cmpi(9, 9) => 0
cmpi(8, 9)
cmpi(8, 9) => -1
swap([2, 3, 5, 9, 8], 3, 4)
swap([2, 3, 5, 8, 9], 3, 4) => ()
cmpi(9, 9)
cmpi(9, 9) => 0
cmpi(8, 9)
cmpi(8, 9) => -1
partition([2, 3, 5, 8, 9], 3, 4) => 3
quicksort([2, 3, 5, 8, 9], 3, 3)
quicksort([2, 3, 5, 8, 9], 3, 3) => ()
quicksort([2, 3, 5, 8, 9], 4, 4)
quicksort([2, 3, 5, 8, 9], 4, 4) => ()
quicksort([2, 3, 5, 8, 9], 3, 4) => ()
quicksort([2, 3, 5, 8, 9], 0, 4) => ()

Final state quicksort.as:

 QS = func
 a = [var 2, 3, 5, 8, 9]
 cmpi = func
 qs = QS/4<Int>



Typechecking hoare.as:

 a : var Int[]
 partition : (var Int[], Int, Int) -> Int
 quicksort : (var Int[], Int, Int) -> ()
 swap : (var Int[], Int, Int) -> ()
 x : ()


Interpreting hoare.as (tracing function calls):

quicksort([8, 3, 9, 5, 2], 0, 4)
partition([8, 3, 9, 5, 2], 0, 4)
swap([8, 3, 9, 5, 2], 0, 4)
swap([2, 3, 9, 5, 8], 0, 4) => ()
swap([2, 3, 9, 5, 8], 2, 3)
swap([2, 3, 5, 9, 8], 2, 3) => ()
partition([2, 3, 5, 9, 8], 0, 4) => 2
quicksort([2, 3, 5, 9, 8], 0, 2)
partition([2, 3, 5, 9, 8], 0, 2)
partition([2, 3, 5, 9, 8], 0, 2) => 0
quicksort([2, 3, 5, 9, 8], 0, 0)
quicksort([2, 3, 5, 9, 8], 0, 0) => ()
quicksort([2, 3, 5, 9, 8], 1, 2)
partition([2, 3, 5, 9, 8], 1, 2)
partition([2, 3, 5, 9, 8], 1, 2) => 1
quicksort([2, 3, 5, 9, 8], 1, 1)
quicksort([2, 3, 5, 9, 8], 1, 1) => ()
quicksort([2, 3, 5, 9, 8], 2, 2)
quicksort([2, 3, 5, 9, 8], 2, 2) => ()
quicksort([2, 3, 5, 9, 8], 1, 2) => ()
quicksort([2, 3, 5, 9, 8], 0, 2) => ()
quicksort([2, 3, 5, 9, 8], 3, 4)
partition([2, 3, 5, 9, 8], 3, 4)
swap([2, 3, 5, 9, 8], 3, 4)
swap([2, 3, 5, 8, 9], 3, 4) => ()
partition([2, 3, 5, 8, 9], 3, 4) => 3
quicksort([2, 3, 5, 8, 9], 3, 3)
quicksort([2, 3, 5, 8, 9], 3, 3) => ()
quicksort([2, 3, 5, 8, 9], 4, 4)
quicksort([2, 3, 5, 8, 9], 4, 4) => ()
quicksort([2, 3, 5, 8, 9], 3, 4) => ()
quicksort([2, 3, 5, 8, 9], 0, 4) => ()

Final state hoare.as:

 a = [var 2, 3, 5, 8, 9]
 partition = func
 quicksort = func
 swap = func
 x = ()



Typechecking bankex.as:

 Account := Account/3
 Bank := Bank/1
 Issuer := Issuer/2
 Account : Int -> Account/3
 Bank : Int -> Bank/1
 Issuer : () -> Issuer/2
 b : Bank/1
 main : async (Account/3, Account/3)
 show : (Text, Account/3) -> ()
 test : () -> async (Account/3, Account/3)
 transfer : (Account/3, Account/3, Int) -> async ()
 Bank/1 <: actor {getIssuer : () -> async Issuer/2; getReserve : () -> async Account/3}
 Issuer/2 <: actor {hasIssued : (like Account/3) -> async Bool}
 Account/3 <: actor {getBalance : () -> async Int; isCompatible : (like Account/3) -> async Bool; join : Account/3 -> (); split : Int -> async Account/3}


Interpreting bankex.as (tracing function calls):

test()
test() => async ?#0
getReserve()
getReserve() => async ?#0
split(10)
split(10) => async ?#0
split(10)
split(10) => async ?#0
show("reserve", {balance = 80; credit = func; getBalance = func; isCompatible = func; join = func; split = func})
show("reserve", {balance = 80; credit = func; getBalance = func; isCompatible = func; join = func; split = func}) => ()
show("a1", {balance = 10; credit = func; getBalance = func; isCompatible = func; join = func; split = func})
show("a1", {balance = 10; credit = func; getBalance = func; isCompatible = func; join = func; split = func}) => ()
show("a2", {balance = 10; credit = func; getBalance = func; isCompatible = func; join = func; split = func})
show("a2", {balance = 10; credit = func; getBalance = func; isCompatible = func; join = func; split = func}) => ()
transfer({balance = 10; credit = func; getBalance = func; isCompatible = func; join = func; split = func}, {balance = 10; credit = func; getBalance = func; isCompatible = func; join = func; split = func}, 5)
transfer({balance = 10; credit = func; getBalance = func; isCompatible = func; join = func; split = func}, {balance = 10; credit = func; getBalance = func; isCompatible = func; join = func; split = func}, 5) => async ?#0
split(5)
split(5) => async ?#0
join({balance = 10; credit = func; getBalance = func; isCompatible = func; join = func; split = func})
credit(5)
credit(5) => ()
join({balance = 15; credit = func; getBalance = func; isCompatible = func; join = func; split = func}) => ()
show("reserve", {balance = 80; credit = func; getBalance = func; isCompatible = func; join = func; split = func})
show("reserve", {balance = 80; credit = func; getBalance = func; isCompatible = func; join = func; split = func}) => ()
show("a1", {balance = 5; credit = func; getBalance = func; isCompatible = func; join = func; split = func})
show("a1", {balance = 5; credit = func; getBalance = func; isCompatible = func; join = func; split = func}) => ()
show("a2", {balance = 15; credit = func; getBalance = func; isCompatible = func; join = func; split = func})
show("a2", {balance = 15; credit = func; getBalance = func; isCompatible = func; join = func; split = func}) => ()

Final state bankex.as:

 Account = func
 Bank = func
 Issuer = func
 b = Bank/1
 main = async (Account/3, Account/3)#0
 show = func
 test = func
 transfer = func



Typechecking counter.as:

 Counter := Counter/1
 Counter : Int -> Counter/1
 c : Counter/1
 show : Int -> ()
 test : () -> ()
 Counter/1 <: actor {dec : () -> (); read : () -> async Int}


Interpreting counter.as (tracing function calls):

test()
test() => ()
dec()
show(10)
show(10) => ()
dec() => ()
dec()
show(9)
show(9) => ()
dec() => ()
dec()
show(8)
show(8) => ()
dec() => ()
dec()
show(7)
show(7) => ()
dec() => ()
dec()
show(6)
show(6) => ()
dec() => ()
dec()
show(5)
show(5) => ()
dec() => ()
dec()
show(4)
show(4) => ()
dec() => ()
dec()
show(3)
show(3) => ()
dec() => ()
dec()
show(2)
show(2) => ()
dec() => ()
dec()
show(1)
show(1) => ()
dec() => ()

Final state counter.as:

 Counter = func
 c = Counter/1
 show = func
 test = func



Typechecking testwhile.as:

 passed : Bool
 test : () -> Int


Interpreting testwhile.as (tracing function calls):

test()
test() => 0

Final state testwhile.as:

 passed = true
 test = func

