
Checking bank.as:
  type Account <: actor {getBalance : () -> async Int; isCompatible : (like Account) -> async Bool; join : Account -> (); split : Int -> async Account}
  type Bank <: actor {getIssuer : () -> async Issuer; getReserve : () -> async Account}
  type Issuer <: actor {hasIssued : (like Account) -> async Bool}
  Account : Int -> Account
  Bank : Int -> Bank
  Issuer : () -> Issuer
  transfer : (Account, Account, Int) -> async ()

Interpreting bank.as:

Finished bank.as:
  Account = func
  Bank = func
  Issuer = func
  transfer = func

Checking bank_ordered.as:
  type Account <: actor {getBalance : () -> async Int; isCompatible : (like Account) -> async Bool; join : Account -> (); split : Int -> async Account}
  type Bank <: actor {getIssuer : () -> async Issuer; getReserve : () -> async Account}
  type Issuer <: actor {hasIssued : (like Account) -> async Bool}
  Account : Int -> Account
  Bank : Int -> Bank
  Issuer : () -> Issuer
  transfer : (Account, Account, Int) -> async ()

Interpreting bank_ordered.as:

Finished bank_ordered.as:
  Account = func
  Bank = func
  Issuer = func
  transfer = func

Checking control.as:
  type Control <: actor {testBlock : () -> (); testLoop : () -> (); testLoopWhile : () -> (); testNestedWhile : () -> (); testWhile : () -> ()}
  Control : () -> Control

Interpreting control.as:

Finished control.as:
  Control = func

Checking literals.as:
  byte : Word8
  i : Int
  i1 : Int
  i2 : Int
  n : Nat
  s : Text
  short : Word16
  u : Char
  word : Word32

Interpreting literals.as:

Finished literals.as:
  byte = 255
  i = 0
  i1 = -1
  i2 = 4095
  n = 0
  s = "a \t\"\u{00}bb\'bc\\de txx\\x\"\u{23442}\n"
  short = 65535
  u = "\u{a34}"
  word = 4294967295

Checking numericops.as:
  testFloat : (Float, Float) -> ()
  testInt : (Int, Int) -> ()
  testNat : (Nat, Nat) -> ()
  testWord16 : (Word16, Word16) -> ()
  testWord32 : (Word32, Word32) -> ()
  testWord64 : (Word64, Word64) -> ()
  testWord8 : (Word8, Word8) -> ()

Interpreting numericops.as:

Finished numericops.as:
  testFloat = func
  testInt = func
  testNat = func
  testWord16 = func
  testWord32 = func
  testWord64 = func
  testWord8 = func

Checking bitops.as:
  testWord16 : (Word16, Word16) -> ()
  testWord32 : (Word32, Word32) -> ()
  testWord64 : (Word64, Word64) -> ()
  testWord8 : (Word8, Word8) -> ()

Interpreting bitops.as:

Finished bitops.as:
  testWord16 = func
  testWord32 = func
  testWord64 = func
  testWord8 = func

Checking relationalops.as:
  testBool : (Bool, Bool) -> ()
  testChar : (Char, Char) -> ()
  testFloat : (Float, Float) -> ()
  testInt : (Int, Int) -> ()
  testNat : (Nat, Nat) -> ()
  testText : (Text, Text) -> ()
  testWord16 : (Word16, Word16) -> ()
  testWord32 : (Word32, Word32) -> ()
  testWord64 : (Word64, Word64) -> ()
  testWord8 : (Word8, Word8) -> ()

Interpreting relationalops.as:

Finished relationalops.as:
  testBool = func
  testChar = func
  testFloat = func
  testInt = func
  testNat = func
  testText = func
  testWord16 = func
  testWord32 = func
  testWord64 = func
  testWord8 = func

Checking concat.as:
  testText : (Text, Text) -> ()

Interpreting concat.as:

Finished concat.as:
  testText = func

Checking duplicatefield.as:
duplicatefield.as:4.3-4.4: type error, duplicate field m

Checking nonlinearpat.as:
nonlinearpat.as:1.5-1.14: type error, duplicate binding for x in pattern

Checking typedef.as:
  type A/1 = (B, A/1)
  type Arrow = <T/8, U/6> T/8 -> U/6
  type B = (A/1, B)
  type Compose = <T/9, U/7, V/3> (T/9 -> U/7) -> (U/7 -> V/3) -> T/9 -> V/3
  type Id = <T/10> T/10 -> T/10
  type IntT = Int
  type Seq = <A/4> (A/4, Seq<A/4>?)

Interpreting typedef.as:

Finished typedef.as:

Checking type_equiv.as:

Interpreting type_equiv.as:

Finished type_equiv.as:

Checking quicksort.as:
  type QS <: <T/4> {quicksort : (var T/4[], Nat, Nat) -> ()}
  QS : <T/4> ((T/4, T/4) -> Int) -> QS<T/4>
  a : var Int[]
  cmpi : (Int, Int) -> Int
  qs : QS<Int>

Interpreting quicksort.as:
  quicksort([8, 3, 9, 5, 2], 0, 4)
  partition([8, 3, 9, 5, 2], 0, 4)
  trace([8, 3, 9, 5, 2])
  trace([8, 3, 9, 5, 2]) => ()
  cmpi(8, 8)
  cmpi(8, 8) => 0
  cmpi(2, 8)
  cmpi(2, 8) => -6
  swap([8, 3, 9, 5, 2], 0, 4)
  swap([2, 3, 9, 5, 8], 0, 4) => ()
  cmpi(2, 8)
  cmpi(2, 8) => -6
  cmpi(3, 8)
  cmpi(3, 8) => -5
  cmpi(9, 8)
  cmpi(9, 8) => 1
  cmpi(8, 8)
  cmpi(8, 8) => 0
  swap([2, 3, 9, 5, 8], 2, 4)
  swap([2, 3, 8, 5, 9], 2, 4) => ()
  cmpi(8, 8)
  cmpi(8, 8) => 0
  cmpi(9, 8)
  cmpi(9, 8) => 1
  cmpi(5, 8)
  cmpi(5, 8) => -3
  swap([2, 3, 8, 5, 9], 2, 3)
  swap([2, 3, 5, 8, 9], 2, 3) => ()
  cmpi(5, 8)
  cmpi(5, 8) => -3
  cmpi(8, 8)
  cmpi(8, 8) => 0
  cmpi(8, 8)
  cmpi(8, 8) => 0
  partition([2, 3, 5, 8, 9], 0, 4) => 3
  quicksort([2, 3, 5, 8, 9], 0, 3)
  partition([2, 3, 5, 8, 9], 0, 3)
  trace([2, 3, 5, 8, 9])
  trace([2, 3, 5, 8, 9]) => ()
  cmpi(2, 2)
  cmpi(2, 2) => 0
  cmpi(8, 2)
  cmpi(8, 2) => 6
  cmpi(5, 2)
  cmpi(5, 2) => 3
  cmpi(3, 2)
  cmpi(3, 2) => 1
  cmpi(2, 2)
  cmpi(2, 2) => 0
  partition([2, 3, 5, 8, 9], 0, 3) => 0
  quicksort([2, 3, 5, 8, 9], 0, 0)
  quicksort([2, 3, 5, 8, 9], 0, 0) => ()
  quicksort([2, 3, 5, 8, 9], 1, 3)
  partition([2, 3, 5, 8, 9], 1, 3)
  trace([2, 3, 5, 8, 9])
  trace([2, 3, 5, 8, 9]) => ()
  cmpi(3, 3)
  cmpi(3, 3) => 0
  cmpi(8, 3)
  cmpi(8, 3) => 5
  cmpi(5, 3)
  cmpi(5, 3) => 2
  cmpi(3, 3)
  cmpi(3, 3) => 0
  partition([2, 3, 5, 8, 9], 1, 3) => 1
  quicksort([2, 3, 5, 8, 9], 1, 1)
  quicksort([2, 3, 5, 8, 9], 1, 1) => ()
  quicksort([2, 3, 5, 8, 9], 2, 3)
  partition([2, 3, 5, 8, 9], 2, 3)
  trace([2, 3, 5, 8, 9])
  trace([2, 3, 5, 8, 9]) => ()
  cmpi(5, 5)
  cmpi(5, 5) => 0
  cmpi(8, 5)
  cmpi(8, 5) => 3
  cmpi(5, 5)
  cmpi(5, 5) => 0
  partition([2, 3, 5, 8, 9], 2, 3) => 2
  quicksort([2, 3, 5, 8, 9], 2, 2)
  quicksort([2, 3, 5, 8, 9], 2, 2) => ()
  quicksort([2, 3, 5, 8, 9], 3, 3)
  quicksort([2, 3, 5, 8, 9], 3, 3) => ()
  quicksort([2, 3, 5, 8, 9], 2, 3) => ()
  quicksort([2, 3, 5, 8, 9], 1, 3) => ()
  quicksort([2, 3, 5, 8, 9], 0, 3) => ()
  quicksort([2, 3, 5, 8, 9], 4, 4)
  quicksort([2, 3, 5, 8, 9], 4, 4) => ()
  quicksort([2, 3, 5, 8, 9], 0, 4) => ()

Finished quicksort.as:
  QS = func
  a = [var 2, 3, 5, 8, 9]
  cmpi = func
  qs = QS<Int>

Checking hoare.as:
  a : var Int[]
  partition : (var Int[], Nat, Nat) -> Nat
  quicksort : (var Int[], Nat, Nat) -> ()
  swap : (var Int[], Nat, Nat) -> ()
  x : ()

Interpreting hoare.as:
  quicksort([8, 3, 9, 5, 2], 0, 4)
  partition([8, 3, 9, 5, 2], 0, 4)
  swap([8, 3, 9, 5, 2], 0, 4)
  swap([2, 3, 9, 5, 8], 0, 4) => ()
  swap([2, 3, 9, 5, 8], 2, 4)
  swap([2, 3, 8, 5, 9], 2, 4) => ()
  swap([2, 3, 8, 5, 9], 2, 3)
  swap([2, 3, 5, 8, 9], 2, 3) => ()
  partition([2, 3, 5, 8, 9], 0, 4) => 3
  quicksort([2, 3, 5, 8, 9], 0, 3)
  partition([2, 3, 5, 8, 9], 0, 3)
  partition([2, 3, 5, 8, 9], 0, 3) => 0
  quicksort([2, 3, 5, 8, 9], 0, 0)
  quicksort([2, 3, 5, 8, 9], 0, 0) => ()
  quicksort([2, 3, 5, 8, 9], 1, 3)
  partition([2, 3, 5, 8, 9], 1, 3)
  partition([2, 3, 5, 8, 9], 1, 3) => 1
  quicksort([2, 3, 5, 8, 9], 1, 1)
  quicksort([2, 3, 5, 8, 9], 1, 1) => ()
  quicksort([2, 3, 5, 8, 9], 2, 3)
  partition([2, 3, 5, 8, 9], 2, 3)
  partition([2, 3, 5, 8, 9], 2, 3) => 2
  quicksort([2, 3, 5, 8, 9], 2, 2)
  quicksort([2, 3, 5, 8, 9], 2, 2) => ()
  quicksort([2, 3, 5, 8, 9], 3, 3)
  quicksort([2, 3, 5, 8, 9], 3, 3) => ()
  quicksort([2, 3, 5, 8, 9], 2, 3) => ()
  quicksort([2, 3, 5, 8, 9], 1, 3) => ()
  quicksort([2, 3, 5, 8, 9], 0, 3) => ()
  quicksort([2, 3, 5, 8, 9], 4, 4)
  quicksort([2, 3, 5, 8, 9], 4, 4) => ()
  quicksort([2, 3, 5, 8, 9], 0, 4) => ()

Finished hoare.as:
  a = [var 2, 3, 5, 8, 9]
  partition = func
  quicksort = func
  swap = func
  x = ()

Checking bankex.as:
  type Account <: actor {getBalance : () -> async Int; isCompatible : (like Account) -> async Bool; join : Account -> (); split : Int -> async Account}
  type Bank <: actor {getIssuer : () -> async Issuer; getReserve : () -> async Account}
  type Issuer <: actor {hasIssued : (like Account) -> async Bool}
  Account : Int -> Account
  Bank : Int -> Bank
  Issuer : () -> Issuer
  b : Bank
  main : async (Account, Account)
  show : (Text, Account) -> ()
  test : () -> async (Account, Account)
  transfer : (Account, Account, Int) -> async ()

Interpreting bankex.as:
  test()
  test() => async ?#0
  getReserve()
  getReserve() => async ?#0
  split(10)
  split(10) => async ?#0
  split(10)
  split(10) => async ?#0
  show("reserve", {balance = 80; credit = func; getBalance = func; isCompatible = func; join = func; split = func})
  show("reserve", {balance = 80; credit = func; getBalance = func; isCompatible = func; join = func; split = func}) => ()
  show("a1", {balance = 10; credit = func; getBalance = func; isCompatible = func; join = func; split = func})
  show("a1", {balance = 10; credit = func; getBalance = func; isCompatible = func; join = func; split = func}) => ()
  show("a2", {balance = 10; credit = func; getBalance = func; isCompatible = func; join = func; split = func})
  show("a2", {balance = 10; credit = func; getBalance = func; isCompatible = func; join = func; split = func}) => ()
  transfer({balance = 10; credit = func; getBalance = func; isCompatible = func; join = func; split = func}, {balance = 10; credit = func; getBalance = func; isCompatible = func; join = func; split = func}, 5)
  transfer({balance = 10; credit = func; getBalance = func; isCompatible = func; join = func; split = func}, {balance = 10; credit = func; getBalance = func; isCompatible = func; join = func; split = func}, 5) => async ?#0
  split(5)
  split(5) => async ?#0
  join({balance = 10; credit = func; getBalance = func; isCompatible = func; join = func; split = func})
  credit(5)
  credit(5) => ()
  join({balance = 15; credit = func; getBalance = func; isCompatible = func; join = func; split = func}) => ()
  show("reserve", {balance = 80; credit = func; getBalance = func; isCompatible = func; join = func; split = func})
  show("reserve", {balance = 80; credit = func; getBalance = func; isCompatible = func; join = func; split = func}) => ()
  show("a1", {balance = 5; credit = func; getBalance = func; isCompatible = func; join = func; split = func})
  show("a1", {balance = 5; credit = func; getBalance = func; isCompatible = func; join = func; split = func}) => ()
  show("a2", {balance = 15; credit = func; getBalance = func; isCompatible = func; join = func; split = func})
  show("a2", {balance = 15; credit = func; getBalance = func; isCompatible = func; join = func; split = func}) => ()

Finished bankex.as:
  Account = func
  Bank = func
  Issuer = func
  b = Bank
  main = async (Account, Account)#0
  show = func
  test = func
  transfer = func

Checking counter.as:
  type Counter <: actor {dec : () -> (); read : () -> async Int}
  Counter : Int -> Counter
  c : Counter
  show : Int -> ()
  test : () -> ()

Interpreting counter.as:
  test()
  test() => ()
  dec()
  show(10)
  show(10) => ()
  dec() => ()
  dec()
  show(9)
  show(9) => ()
  dec() => ()
  dec()
  show(8)
  show(8) => ()
  dec() => ()
  dec()
  show(7)
  show(7) => ()
  dec() => ()
  dec()
  show(6)
  show(6) => ()
  dec() => ()
  dec()
  show(5)
  show(5) => ()
  dec() => ()
  dec()
  show(4)
  show(4) => ()
  dec() => ()
  dec()
  show(3)
  show(3) => ()
  dec() => ()
  dec()
  show(2)
  show(2) => ()
  dec() => ()
  dec()
  show(1)
  show(1) => ()
  dec() => ()

Finished counter.as:
  Counter = func
  c = Counter
  show = func
  test = func

Checking testwhile.as:
  passed : Bool
  test : () -> Int

Interpreting testwhile.as:
  test()
  test() => 0

Finished testwhile.as:
  passed = true
  test = func

Checking overflow.as:

Interpreting overflow.as:
overflow.as:17.1-17.16: execution error, arithmetic overflow
