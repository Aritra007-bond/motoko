-- Checking bank.as:
type Account <: actor {getBalance : () -> async Int; isCompatible : (like Account) -> async Bool; join : Account -> (); split : Int -> async Account}
type Bank <: actor {getIssuer : () -> async Issuer; getReserve : () -> async Account}
type Issuer <: actor {hasIssued : (like Account) -> async Bool}
let Account : Int -> Account
let Bank : Int -> Bank
let Issuer : () -> Issuer
let transfer : (Account, Account, Int) -> async ()
-- Interpreting bank.as:
-- Finished bank.as:
let Account : Int -> Account = func
let Bank : Int -> Bank = func
let Issuer : () -> Issuer = func
let transfer : (Account, Account, Int) -> async () = func

-- Checking bank_ordered.as:
type Account <: actor {getBalance : () -> async Int; isCompatible : (like Account) -> async Bool; join : Account -> (); split : Int -> async Account}
type Bank <: actor {getIssuer : () -> async Issuer; getReserve : () -> async Account}
type Issuer <: actor {hasIssued : (like Account) -> async Bool}
let Account : Int -> Account
let Bank : Int -> Bank
let Issuer : () -> Issuer
let transfer : (Account, Account, Int) -> async ()
-- Interpreting bank_ordered.as:
-- Finished bank_ordered.as:
let Account : Int -> Account = func
let Bank : Int -> Bank = func
let Issuer : () -> Issuer = func
let transfer : (Account, Account, Int) -> async () = func

-- Checking control.as:
type Control <: actor {testBlock : () -> (); testLoop : () -> (); testLoopWhile : () -> (); testNestedWhile : () -> (); testWhile : () -> ()}
let Control : () -> Control
-- Interpreting control.as:
-- Finished control.as:
let Control : () -> Control = func

-- Checking literals.as:
let byte : Word8
let i : Int
let i1 : Int
let i2 : Int
let n : Nat
let s : Text
let short : Word16
let u : Char
let word : Word32
-- Interpreting literals.as:
-- Finished literals.as:
let byte : Word8 = 255
let i : Int = 0
let i1 : Int = -1
let i2 : Int = 4095
let n : Nat = 0
let s : Text = "a \t\"\u{00}bb\'bc\\de txx\\x\"\u{23442}\n"
let short : Word16 = 65535
let u : Char = "\u{a34}"
let word : Word32 = 4294967295

-- Checking numericops.as:
let testFloat : (Float, Float) -> ()
let testInt : (Int, Int) -> ()
let testNat : (Nat, Nat) -> ()
let testWord16 : (Word16, Word16) -> ()
let testWord32 : (Word32, Word32) -> ()
let testWord64 : (Word64, Word64) -> ()
let testWord8 : (Word8, Word8) -> ()
-- Interpreting numericops.as:
-- Finished numericops.as:
let testFloat : (Float, Float) -> () = func
let testInt : (Int, Int) -> () = func
let testNat : (Nat, Nat) -> () = func
let testWord16 : (Word16, Word16) -> () = func
let testWord32 : (Word32, Word32) -> () = func
let testWord64 : (Word64, Word64) -> () = func
let testWord8 : (Word8, Word8) -> () = func

-- Checking bitops.as:
let testWord16 : (Word16, Word16) -> ()
let testWord32 : (Word32, Word32) -> ()
let testWord64 : (Word64, Word64) -> ()
let testWord8 : (Word8, Word8) -> ()
-- Interpreting bitops.as:
-- Finished bitops.as:
let testWord16 : (Word16, Word16) -> () = func
let testWord32 : (Word32, Word32) -> () = func
let testWord64 : (Word64, Word64) -> () = func
let testWord8 : (Word8, Word8) -> () = func

-- Checking relationalops.as:
let testBool : (Bool, Bool) -> ()
let testChar : (Char, Char) -> ()
let testFloat : (Float, Float) -> ()
let testInt : (Int, Int) -> ()
let testNat : (Nat, Nat) -> ()
let testText : (Text, Text) -> ()
let testWord16 : (Word16, Word16) -> ()
let testWord32 : (Word32, Word32) -> ()
let testWord64 : (Word64, Word64) -> ()
let testWord8 : (Word8, Word8) -> ()
-- Interpreting relationalops.as:
-- Finished relationalops.as:
let testBool : (Bool, Bool) -> () = func
let testChar : (Char, Char) -> () = func
let testFloat : (Float, Float) -> () = func
let testInt : (Int, Int) -> () = func
let testNat : (Nat, Nat) -> () = func
let testText : (Text, Text) -> () = func
let testWord16 : (Word16, Word16) -> () = func
let testWord32 : (Word32, Word32) -> () = func
let testWord64 : (Word64, Word64) -> () = func
let testWord8 : (Word8, Word8) -> () = func

-- Checking concat.as:
let testText : (Text, Text) -> ()
-- Interpreting concat.as:
-- Finished concat.as:
let testText : (Text, Text) -> () = func

-- Checking duplicatefield.as:
duplicatefield.as:4.3-4.4: type error, duplicate field name m in object

-- Checking nonlinearpat.as:
nonlinearpat.as:1.11-1.12: type error, duplicate binding for x in block

-- Checking typedef.as:
type A/1 = (B, A/1)
type Arrow<T, U> = T.1 -> U.1
type B = (A/1, B)
type Compose<T, U, V> = (T.2 -> U.2) -> (U.3 -> V.3) -> T.3 -> V.3
type Id = <T>T -> T
type IntT = Int
type Seq<A> = (A, Seq<A>?)
-- Interpreting typedef.as:
-- Finished typedef.as:

-- Checking type_equiv.as:
-- Interpreting type_equiv.as:
-- Finished type_equiv.as:

-- Checking quicksort.as:
type QS<T> <: {quicksort : (var T.1[], Nat, Nat) -> ()}
let QS : <T>((T.1, T.1) -> Int) -> QS<T>
let a : var Int[]
let cmpi : (Int, Int) -> Int
let qs : QS<Int>
-- Interpreting quicksort.as:
QS(func)
  <= {partition = func; quicksort = func; swap = func; trace = func}
quicksort([8, 3, 9, 5, 2], 0, 4)
  partition([8, 3, 9, 5, 2], 0, 4)
    trace([8, 3, 9, 5, 2])
      <= ()
    cmpi(8, 8)
      <= 0
    cmpi(2, 8)
      <= -6
    swap([8, 3, 9, 5, 2], 0, 4)
      <= ()
    cmpi(2, 8)
      <= -6
    cmpi(3, 8)
      <= -5
    cmpi(9, 8)
      <= 1
    cmpi(8, 8)
      <= 0
    swap([2, 3, 9, 5, 8], 2, 4)
      <= ()
    cmpi(8, 8)
      <= 0
    cmpi(9, 8)
      <= 1
    cmpi(5, 8)
      <= -3
    swap([2, 3, 8, 5, 9], 2, 3)
      <= ()
    cmpi(5, 8)
      <= -3
    cmpi(8, 8)
      <= 0
    cmpi(8, 8)
      <= 0
    <= 3
  quicksort([2, 3, 5, 8, 9], 0, 3)
    partition([2, 3, 5, 8, 9], 0, 3)
      trace([2, 3, 5, 8, 9])
        <= ()
      cmpi(2, 2)
        <= 0
      cmpi(8, 2)
        <= 6
      cmpi(5, 2)
        <= 3
      cmpi(3, 2)
        <= 1
      cmpi(2, 2)
        <= 0
      <= 0
    quicksort([2, 3, 5, 8, 9], 0, 0)
      <= ()
    quicksort([2, 3, 5, 8, 9], 1, 3)
      partition([2, 3, 5, 8, 9], 1, 3)
        trace([2, 3, 5, 8, 9])
          <= ()
        cmpi(3, 3)
          <= 0
        cmpi(8, 3)
          <= 5
        cmpi(5, 3)
          <= 2
        cmpi(3, 3)
          <= 0
        <= 1
      quicksort([2, 3, 5, 8, 9], 1, 1)
        <= ()
      quicksort([2, 3, 5, 8, 9], 2, 3)
        partition([2, 3, 5, 8, 9], 2, 3)
          trace([2, 3, 5, 8, 9])
            <= ()
          cmpi(5, 5)
            <= 0
          cmpi(8, 5)
            <= 3
          cmpi(5, 5)
            <= 0
          <= 2
        quicksort([2, 3, 5, 8, 9], 2, 2)
          <= ()
        quicksort([2, 3, 5, 8, 9], 3, 3)
          <= ()
        <= ()
      <= ()
    <= ()
  quicksort([2, 3, 5, 8, 9], 4, 4)
    <= ()
  <= ()
-- Finished quicksort.as:
let QS : <T>((T.1, T.1) -> Int) -> QS<T> = func
let a : var Int[] = [2, 3, 5, 8, 9]
let cmpi : (Int, Int) -> Int = func
let qs : QS<Int> = QS<Int>

-- Checking hoare.as:
let a : var Int[]
let partition : (var Int[], Nat, Nat) -> Nat
let quicksort : (var Int[], Nat, Nat) -> ()
let swap : (var Int[], Nat, Nat) -> ()
let x : ()
-- Interpreting hoare.as:
quicksort([8, 3, 9, 5, 2], 0, 4)
  partition([8, 3, 9, 5, 2], 0, 4)
    swap([8, 3, 9, 5, 2], 0, 4)
      <= ()
    swap([2, 3, 9, 5, 8], 2, 4)
      <= ()
    swap([2, 3, 8, 5, 9], 2, 3)
      <= ()
    <= 3
  quicksort([2, 3, 5, 8, 9], 0, 3)
    partition([2, 3, 5, 8, 9], 0, 3)
      <= 0
    quicksort([2, 3, 5, 8, 9], 0, 0)
      <= ()
    quicksort([2, 3, 5, 8, 9], 1, 3)
      partition([2, 3, 5, 8, 9], 1, 3)
        <= 1
      quicksort([2, 3, 5, 8, 9], 1, 1)
        <= ()
      quicksort([2, 3, 5, 8, 9], 2, 3)
        partition([2, 3, 5, 8, 9], 2, 3)
          <= 2
        quicksort([2, 3, 5, 8, 9], 2, 2)
          <= ()
        quicksort([2, 3, 5, 8, 9], 3, 3)
          <= ()
        <= ()
      <= ()
    <= ()
  quicksort([2, 3, 5, 8, 9], 4, 4)
    <= ()
  <= ()
-- Finished hoare.as:
let a : var Int[] = [2, 3, 5, 8, 9]
let partition : (var Int[], Nat, Nat) -> Nat = func
let quicksort : (var Int[], Nat, Nat) -> () = func
let swap : (var Int[], Nat, Nat) -> () = func
let x : () = ()

-- Checking bankex.as:
type Account <: actor {getBalance : () -> async Int; isCompatible : (like Account) -> async Bool; join : Account -> (); split : Int -> async Account}
type Bank <: actor {getIssuer : () -> async Issuer; getReserve : () -> async Account}
type Issuer <: actor {hasIssued : (like Account) -> async Bool}
let Account : Int -> Account
let Bank : Int -> Bank
let Issuer : () -> Issuer
let b : Bank
let main : async (Account, Account)
let show : (Text, Account) -> ()
let test : () -> async (Account, Account)
let transfer : (Account, Account, Int) -> async ()
-- Interpreting bankex.as:
Bank(100)
  Issuer()
    <= {hasIssued = func}
  Account(100)
    <= {balance = 100; credit = func; getBalance = func; isCompatible = func; join = func; split = func}
  <= {getIssuer = func; getReserve = func; issuer = {hasIssued = func}; reserve = {balance = 100; credit = func; getBalance = func; isCompatible = func; join = func; split = func}}
test()
  -> async bankex.as:55.40-67.2
  <= async _ #0
<- async bankex.as:55.40-67.2
  -> message getReserve()
  => await bankex.as:56.17-56.37
<- message getReserve()
  getReserve()
    -> async bankex.as:5.32-6.21
    <= async _ #0
<- async bankex.as:5.32-6.21
<- await bankex.as:56.17-56.37({balance = 100; credit = func; getBalance = func; isCompatible = func; join = func; split = func})
  -> message split(10)
  => await bankex.as:57.12-57.35
<- message split(10)
  split(10)
    -> async bankex.as:22.39-25.4
    <= async _ #0
<- async bankex.as:22.39-25.4
  Account(10)
    <= {balance = 10; credit = func; getBalance = func; isCompatible = func; join = func; split = func}
<- await bankex.as:57.12-57.35({balance = 10; credit = func; getBalance = func; isCompatible = func; join = func; split = func})
  -> message split(10)
  => await bankex.as:58.12-58.35
<- message split(10)
  split(10)
    -> async bankex.as:22.39-25.4
    <= async _ #0
<- async bankex.as:22.39-25.4
  Account(10)
    <= {balance = 10; credit = func; getBalance = func; isCompatible = func; join = func; split = func}
<- await bankex.as:58.12-58.35({balance = 10; credit = func; getBalance = func; isCompatible = func; join = func; split = func})
  show("reserve", {balance = 80; credit = func; getBalance = func; isCompatible = func; join = func; split = func})
    <= ()
  show("a1", {balance = 10; credit = func; getBalance = func; isCompatible = func; join = func; split = func})
    <= ()
  show("a2", {balance = 10; credit = func; getBalance = func; isCompatible = func; join = func; split = func})
    <= ()
  transfer({balance = 10; credit = func; getBalance = func; isCompatible = func; join = func; split = func}, {balance = 10; credit = func; getBalance = func; isCompatible = func; join = func; split = func}, 5)
    -> async bankex.as:45.91-48.2
    <= async _ #0
  => await bankex.as:62.3-62.28
<- async bankex.as:45.91-48.2
  -> message split(5)
  => await bankex.as:46.13-46.39
<- message split(5)
  split(5)
    -> async bankex.as:22.39-25.4
    <= async _ #0
<- async bankex.as:22.39-25.4
  Account(5)
    <= {balance = 5; credit = func; getBalance = func; isCompatible = func; join = func; split = func}
<- await bankex.as:46.13-46.39({balance = 5; credit = func; getBalance = func; isCompatible = func; join = func; split = func})
  -> message join({balance = 10; credit = func; getBalance = func; isCompatible = func; join = func; split = func})
  <= ()
<- message join({balance = 10; credit = func; getBalance = func; isCompatible = func; join = func; split = func})
  join({balance = 10; credit = func; getBalance = func; isCompatible = func; join = func; split = func})
    credit(5)
      <= ()
    <= ()
<- await bankex.as:62.3-62.28()
  show("reserve", {balance = 80; credit = func; getBalance = func; isCompatible = func; join = func; split = func})
    <= ()
  show("a1", {balance = 5; credit = func; getBalance = func; isCompatible = func; join = func; split = func})
    <= ()
  show("a2", {balance = 15; credit = func; getBalance = func; isCompatible = func; join = func; split = func})
    <= ()
  <= ({balance = 5; credit = func; getBalance = func; isCompatible = func; join = func; split = func}, {balance = 15; credit = func; getBalance = func; isCompatible = func; join = func; split = func})
-- Finished bankex.as:
let Account : Int -> Account = func
let Bank : Int -> Bank = func
let Issuer : () -> Issuer = func
let b : Bank = Bank
let main : async (Account, Account) = async (Account, Account)
let show : (Text, Account) -> () = func
let test : () -> async (Account, Account) = func
let transfer : (Account, Account, Int) -> async () = func

-- Checking counter.as:
type Counter <: actor {dec : () -> (); read : () -> async Int}
let Counter : Int -> Counter
let c : Counter
let show : Int -> ()
let test : () -> ()
-- Interpreting counter.as:
Counter(10)
  <= {c = 10; dec = func; read = func}
test()
  -> message dec()
  -> message dec()
  -> message dec()
  -> message dec()
  -> message dec()
  -> message dec()
  -> message dec()
  -> message dec()
  -> message dec()
  -> message dec()
  <= ()
<- message dec()
  dec()
    show(10)
      <= ()
    <= ()
<- message dec()
  dec()
    show(9)
      <= ()
    <= ()
<- message dec()
  dec()
    show(8)
      <= ()
    <= ()
<- message dec()
  dec()
    show(7)
      <= ()
    <= ()
<- message dec()
  dec()
    show(6)
      <= ()
    <= ()
<- message dec()
  dec()
    show(5)
      <= ()
    <= ()
<- message dec()
  dec()
    show(4)
      <= ()
    <= ()
<- message dec()
  dec()
    show(3)
      <= ()
    <= ()
<- message dec()
  dec()
    show(2)
      <= ()
    <= ()
<- message dec()
  dec()
    show(1)
      <= ()
    <= ()
-- Finished counter.as:
let Counter : Int -> Counter = func
let c : Counter = Counter
let show : Int -> () = func
let test : () -> () = func

-- Checking testwhile.as:
let passed : Bool
let test : () -> Int
-- Interpreting testwhile.as:
test()
  <= 0
-- Finished testwhile.as:
let passed : Bool = true
let test : () -> Int = func

-- Checking objects.as:
type O = {self : () -> O}
type Q = {this : var Q?}
let ignore : (async ()) -> ()
let o : {self : () -> O}
let oo : O
let p : {get_y : () -> Int; x : Nat}
let q : Q
let tictac : {tac : Int -> (); tic : Int -> ()}
let tictac_actor : actor {tac_msg : Int -> (); tic_msg : Int -> ()}
let tictac_actor_async : actor {tac_msg_async : Int -> async (); tic_msg_async : Int -> async ()}
let tictac_async : {tac_async : Int -> async (); tic_async : Int -> async ()}
let x : Nat
let y : Int
-- Interpreting objects.as:
get_y()
  <= 2
self()
  <= {self = func}
tic(10)
  tac(9)
    tic(8)
      tac(7)
        tic(6)
          tac(5)
            tic(4)
              tac(3)
                tic(2)
                  tac(1)
                    tic(0)
                      <= ()
                    <= ()
                  <= ()
                <= ()
              <= ()
            <= ()
          <= ()
        <= ()
      <= ()
    <= ()
  <= ()
-> message tic_msg(10)
tic_async(10)
  -> async objects.as:28.33-28.77
  <= async _ #0
-> message tic_msg_async(10)
-> async objects.as:39.9-39.18
objects.as:40.9-40.12: execution error, arithmetic overflow
<- message tic_msg(10)
  tic_msg(10)
    -> message tac_msg(9)
    <= ()
<- async objects.as:28.33-28.77
  tac_async(9)
    -> async objects.as:29.33-29.77
    <= async _ #0
  ignore(async _ #0)
    <= ()
  <= ()
<- message tic_msg_async(10)
  tic_msg_async(10)
    -> async objects.as:34.37-34.85
    <= async _ #0
<- async objects.as:39.9-39.18
objects.as:39.15-39.18: execution error, arithmetic overflow
<- message tac_msg(9)
  tac_msg(9)
    -> message tic_msg(8)
    <= ()
<- async objects.as:29.33-29.77
  tic_async(8)
    -> async objects.as:28.33-28.77
    <= async _ #0
  ignore(async _ #0)
    <= ()
  <= ()
<- async objects.as:34.37-34.85
  -> message tac_msg_async(9)
  ignore(async _ #0)
    <= ()
  <= ()
<- message tic_msg(8)
  tic_msg(8)
    -> message tac_msg(7)
    <= ()
<- async objects.as:28.33-28.77
  tac_async(7)
    -> async objects.as:29.33-29.77
    <= async _ #0
  ignore(async _ #0)
    <= ()
  <= ()
<- message tac_msg_async(9)
  tac_msg_async(9)
    -> async objects.as:35.37-35.85
    <= async _ #0
<- message tac_msg(7)
  tac_msg(7)
    -> message tic_msg(6)
    <= ()
<- async objects.as:29.33-29.77
  tic_async(6)
    -> async objects.as:28.33-28.77
    <= async _ #0
  ignore(async _ #0)
    <= ()
  <= ()
<- async objects.as:35.37-35.85
  -> message tic_msg_async(8)
  ignore(async _ #0)
    <= ()
  <= ()
<- message tic_msg(6)
  tic_msg(6)
    -> message tac_msg(5)
    <= ()
<- async objects.as:28.33-28.77
  tac_async(5)
    -> async objects.as:29.33-29.77
    <= async _ #0
  ignore(async _ #0)
    <= ()
  <= ()
<- message tic_msg_async(8)
  tic_msg_async(8)
    -> async objects.as:34.37-34.85
    <= async _ #0
<- message tac_msg(5)
  tac_msg(5)
    -> message tic_msg(4)
    <= ()
<- async objects.as:29.33-29.77
  tic_async(4)
    -> async objects.as:28.33-28.77
    <= async _ #0
  ignore(async _ #0)
    <= ()
  <= ()
<- async objects.as:34.37-34.85
  -> message tac_msg_async(7)
  ignore(async _ #0)
    <= ()
  <= ()
<- message tic_msg(4)
  tic_msg(4)
    -> message tac_msg(3)
    <= ()
<- async objects.as:28.33-28.77
  tac_async(3)
    -> async objects.as:29.33-29.77
    <= async _ #0
  ignore(async _ #0)
    <= ()
  <= ()
<- message tac_msg_async(7)
  tac_msg_async(7)
    -> async objects.as:35.37-35.85
    <= async _ #0
<- message tac_msg(3)
  tac_msg(3)
    -> message tic_msg(2)
    <= ()
<- async objects.as:29.33-29.77
  tic_async(2)
    -> async objects.as:28.33-28.77
    <= async _ #0
  ignore(async _ #0)
    <= ()
  <= ()
<- async objects.as:35.37-35.85
  -> message tic_msg_async(6)
  ignore(async _ #0)
    <= ()
  <= ()
<- message tic_msg(2)
  tic_msg(2)
    -> message tac_msg(1)
    <= ()
<- async objects.as:28.33-28.77
  tac_async(1)
    -> async objects.as:29.33-29.77
    <= async _ #0
  ignore(async _ #0)
    <= ()
  <= ()
<- message tic_msg_async(6)
  tic_msg_async(6)
    -> async objects.as:34.37-34.85
    <= async _ #0
<- message tac_msg(1)
  tac_msg(1)
    -> message tic_msg(0)
    <= ()
<- async objects.as:29.33-29.77
  tic_async(0)
    -> async objects.as:28.33-28.77
    <= async _ #0
  ignore(async _ #0)
    <= ()
  <= ()
<- async objects.as:34.37-34.85
  -> message tac_msg_async(5)
  ignore(async _ #0)
    <= ()
  <= ()
<- message tic_msg(0)
  tic_msg(0)
    <= ()
<- async objects.as:28.33-28.77
  <= ()
<- message tac_msg_async(5)
  tac_msg_async(5)
    -> async objects.as:35.37-35.85
    <= async _ #0
<- async objects.as:35.37-35.85
  -> message tic_msg_async(4)
  ignore(async _ #0)
    <= ()
  <= ()
<- message tic_msg_async(4)
  tic_msg_async(4)
    -> async objects.as:34.37-34.85
    <= async _ #0
<- async objects.as:34.37-34.85
  -> message tac_msg_async(3)
  ignore(async _ #0)
    <= ()
  <= ()
<- message tac_msg_async(3)
  tac_msg_async(3)
    -> async objects.as:35.37-35.85
    <= async _ #0
<- async objects.as:35.37-35.85
  -> message tic_msg_async(2)
  ignore(async _ #0)
    <= ()
  <= ()
<- message tic_msg_async(2)
  tic_msg_async(2)
    -> async objects.as:34.37-34.85
    <= async _ #0
<- async objects.as:34.37-34.85
  -> message tac_msg_async(1)
  ignore(async _ #0)
    <= ()
  <= ()
<- message tac_msg_async(1)
  tac_msg_async(1)
    -> async objects.as:35.37-35.85
    <= async _ #0
<- async objects.as:35.37-35.85
  -> message tic_msg_async(0)
  ignore(async _ #0)
    <= ()
  <= ()
<- message tic_msg_async(0)
  tic_msg_async(0)
    -> async objects.as:34.37-34.85
    <= async _ #0
<- async objects.as:34.37-34.85
  <= ()
-- Finished objects.as:
let ignore : (async ()) -> () = func
let o : {self : () -> O} = {self = func}
let oo : O = {self = func}
let p : {get_y : () -> Int; x : Nat} = {get_y = func; x = 3}
let q : Q = {this = {this = {...}}}
let tictac : {tac : Int -> (); tic : Int -> ()} = {tac = func; tic = func}
let tictac_actor : actor {tac_msg : Int -> (); tic_msg : Int -> ()} = actor {tac_msg = func; tic_msg = func}
let tictac_actor_async : actor {tac_msg_async : Int -> async (); tic_msg_async : Int -> async ()} = actor {tac_msg_async = func; tic_msg_async = func}
let tictac_async : {tac_async : Int -> async (); tic_async : Int -> async ()} = {tac_async = func; tic_async = func}
let x : Nat = 3
let y : Int = 2

-- Checking overflow.as:
-- Interpreting overflow.as:
overflow.as:17.9-17.24: execution error, arithmetic overflow
-- Finished overflow.as:

-- Checking menhirbug.as:
type A = {x : {}}
-- Interpreting menhirbug.as:
-- Finished menhirbug.as:

