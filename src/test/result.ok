typechecked bank.as

 Account := Account/3
 Bank := Bank/1
 Issuer := Issuer/2
 Account : Int -> Account/3
 Bank : Int -> Bank/1
 Issuer : () -> Issuer/2
 transfer : (Account/3, Account/3, Int) -> async ()
 Bank/1 := actor {getIssuer : () -> async Issuer/2; getReserve : () -> async Account/3}
 Issuer/2 := actor {hasIssued : (like Account/3) -> async Bool}
 Account/3 := actor {getBalance : () -> async Int; isCompatible : (like Account/3) -> async Bool; join : Account/3 -> (); split : Int -> async Account/3}
 Account = func ...
 Bank = func ...
 Issuer = func ...
 transfer = func ...
typechecked bank_ordered.as

 Account := Account/1
 Bank := Bank/3
 Issuer := Issuer/2
 Account : Int -> Account/1
 Bank : Int -> Bank/3
 Issuer : () -> Issuer/2
 transfer : (Account/1, Account/1, Int) -> async ()
 Account/1 := actor {getBalance : () -> async Int; isCompatible : (like Account/1) -> async Bool; join : Account/1 -> (); split : Int -> async Account/1}
 Issuer/2 := actor {hasIssued : (like Account/1) -> async Bool}
 Bank/3 := actor {getIssuer : () -> async Issuer/2; getReserve : () -> async Account/1}
 Account = func ...
 Bank = func ...
 Issuer = func ...
 transfer = func ...
typechecked control.as

 Control := Control/1
 Control : () -> Control/1
 Control/1 := actor {testBlock : () -> (); testLoop : () -> (); testLoopWhile : () -> (); testNestedWhile : () -> (); testWhile : () -> ()}
 Control = func ...
Type Error literals.as:3.20-3.27:bad or out-of-range literal for type Word8!
typechecked numericops.as

 testFloat : (Float, Float) -> ()
 testInt : (Int, Int) -> ()
 testNat : (Nat, Nat) -> ()
 testWord16 : (Word16, Word16) -> ()
 testWord32 : (Word32, Word32) -> ()
 testWord64 : (Word64, Word64) -> ()
 testWord8 : (Word8, Word8) -> ()
 testFloat = func ...
 testInt = func ...
 testNat = func ...
 testWord16 = func ...
 testWord32 = func ...
 testWord64 = func ...
 testWord8 = func ...
typechecked bitops.as

 testWord16 : (Word16, Word16) -> ()
 testWord32 : (Word32, Word32) -> ()
 testWord64 : (Word64, Word64) -> ()
 testWord8 : (Word8, Word8) -> ()
 testWord16 = func ...
 testWord32 = func ...
 testWord64 = func ...
 testWord8 = func ...
typechecked relationalops.as

 testBool : (Bool, Bool) -> ()
 testChar : (Char, Char) -> ()
 testFloat : (Float, Float) -> ()
 testInt : (Int, Int) -> ()
 testNat : (Nat, Nat) -> ()
 testText : (Text, Text) -> ()
 testWord16 : (Word16, Word16) -> ()
 testWord32 : (Word32, Word32) -> ()
 testWord64 : (Word64, Word64) -> ()
 testWord8 : (Word8, Word8) -> ()
 testBool = func ...
 testChar = func ...
 testFloat = func ...
 testInt = func ...
 testNat = func ...
 testText = func ...
 testWord16 = func ...
 testWord32 = func ...
 testWord64 = func ...
 testWord8 = func ...
typechecked concat.as

 testText : (Text, Text) -> ()
 testText = func ...
Type Error duplicatefield.as:4.3-4.4:duplicate field m!
Type Error nonlinearpat.as:1.5-1.14:duplicate binding for x in pattern!
typechecked typedef.as

 A := A/12
 Arrow := Arrow/4
 B := B/13
 Compose := Compose/8
 Id := Id/9
 IntT := IntT/1
 Seq := Seq/11
 IntT/1 = Int
 Arrow/4 = <T/28, U/29> T/28 -> U/29
 Compose/8 = <T/30, U/31, V/32> (T/30 -> U/31) -> (U/31 -> V/32) -> T/30 -> V/32
 Id/9 = <T/33> T/33 -> T/33
 Seq/11 = <A/34> (A/34, Seq/11<A/34>?)
 A/12 = (B/13, A/12)
 B/13 = (A/12, B/13)
typechecked type_equiv.as

 A := A/5
 T := T/3
 A : <t/26> () -> A/5<t/26>
 test0 : (T/3<Int, Bool>, T/3<Int, Nat>) -> T/3<Int, Word8>
 test1 : (<t/27> t/27 -> t/27, <u/28> u/28 -> u/28) -> <c/29> c/29 -> c/29
 test2 : (<t/30, u/31> t/30 -> u/31, <t/32, u/33> t/32 -> u/33) -> <t/34, u/35> t/34 -> u/35
 test3 : (A/5<Int>, A/5<Int>) -> A/5<Int>
 test4 : <t/36> (A/5<t/36>, A/5<t/36>) -> A/5<t/36>
 test5 : <t/37> (A/5<T/3<t/37, Int>>, A/5<T/3<t/37, Bool>>) -> A/5<T/3<t/37, Word8>>
 test6 : <t/38> (A/5<T/3<t/38, Int>>, A/5<T/3<t/38, Bool>>) -> A/5<T/3<t/38, Word8>>
 T/3 = <a/24, b/25> a/24
 A/5 := <t/26> actor {}
 A = func ...
 test0 = func ...
 test1 = func ...
 test2 = func ...
 test3 = func ...
 test4 = func ...
 test5 = func ...
 test6 = func ...
typechecked quicksort.as

 QS := QS/4
 array := array/2
 QS : <T/11> ((T/11, T/11) -> Int) -> QS/4<T/11>
 a : var Int[]
 cmpi : (Int, Int) -> Int
 qs : QS/4<Int>
 array/2 = <t/10> var t/10[]
 QS/4 := <T/11> {quicksort : (array/2<T/11>, Int, Int) -> ()}
quicksort([8, 3, 9, 5, 2], 0, 4)
partition([8, 3, 9, 5, 2], 0, 4)
trace([8, 3, 9, 5, 2])
trace([8, 3, 9, 5, 2]) => ()
cmpi(8, 8)
cmpi(8, 8) => 0
cmpi(2, 8)
cmpi(2, 8) => -6
swap([8, 3, 9, 5, 2], 0, 4)
swap([2, 3, 9, 5, 8], 0, 4) => ()
cmpi(3, 8)
cmpi(3, 8) => -5
cmpi(9, 8)
cmpi(9, 8) => 1
cmpi(5, 8)
cmpi(5, 8) => -3
swap([2, 3, 9, 5, 8], 2, 3)
swap([2, 3, 5, 9, 8], 2, 3) => ()
cmpi(9, 8)
cmpi(9, 8) => 1
cmpi(5, 8)
cmpi(5, 8) => -3
partition([2, 3, 5, 9, 8], 0, 4) => 2
quicksort([2, 3, 5, 9, 8], 0, 2)
partition([2, 3, 5, 9, 8], 0, 2)
trace([2, 3, 5, 9, 8])
trace([2, 3, 5, 9, 8]) => ()
cmpi(2, 2)
cmpi(2, 2) => 0
cmpi(5, 2)
cmpi(5, 2) => 3
cmpi(3, 2)
cmpi(3, 2) => 1
cmpi(2, 2)
cmpi(2, 2) => 0
partition([2, 3, 5, 9, 8], 0, 2) => 0
quicksort([2, 3, 5, 9, 8], 0, 0)
quicksort([2, 3, 5, 9, 8], 0, 0) => ()
quicksort([2, 3, 5, 9, 8], 1, 2)
partition([2, 3, 5, 9, 8], 1, 2)
trace([2, 3, 5, 9, 8])
trace([2, 3, 5, 9, 8]) => ()
cmpi(3, 3)
cmpi(3, 3) => 0
cmpi(5, 3)
cmpi(5, 3) => 2
cmpi(3, 3)
cmpi(3, 3) => 0
partition([2, 3, 5, 9, 8], 1, 2) => 1
quicksort([2, 3, 5, 9, 8], 1, 1)
quicksort([2, 3, 5, 9, 8], 1, 1) => ()
quicksort([2, 3, 5, 9, 8], 2, 2)
quicksort([2, 3, 5, 9, 8], 2, 2) => ()
quicksort([2, 3, 5, 9, 8], 1, 2) => ()
quicksort([2, 3, 5, 9, 8], 0, 2) => ()
quicksort([2, 3, 5, 9, 8], 3, 4)
partition([2, 3, 5, 9, 8], 3, 4)
trace([2, 3, 5, 9, 8])
trace([2, 3, 5, 9, 8]) => ()
cmpi(9, 9)
cmpi(9, 9) => 0
cmpi(8, 9)
cmpi(8, 9) => -1
swap([2, 3, 5, 9, 8], 3, 4)
swap([2, 3, 5, 8, 9], 3, 4) => ()
cmpi(9, 9)
cmpi(9, 9) => 0
cmpi(8, 9)
cmpi(8, 9) => -1
partition([2, 3, 5, 8, 9], 3, 4) => 3
quicksort([2, 3, 5, 8, 9], 3, 3)
quicksort([2, 3, 5, 8, 9], 3, 3) => ()
quicksort([2, 3, 5, 8, 9], 4, 4)
quicksort([2, 3, 5, 8, 9], 4, 4) => ()
quicksort([2, 3, 5, 8, 9], 3, 4) => ()
quicksort([2, 3, 5, 8, 9], 0, 4) => ()
 QS = func ...
 a = [var 2, 3, 5, 8, 9]
 cmpi = func ...
 qs = QS/4<Int>
typechecked hoare.as

 a : var Int[]
 partition : (var Int[], Int, Int) -> Int
 quicksort : (var Int[], Int, Int) -> ()
 swap : (var Int[], Int, Int) -> ()
 x : ()
quicksort([8, 3, 9, 5, 2], 0, 4)
partition([8, 3, 9, 5, 2], 0, 4)
swap([8, 3, 9, 5, 2], 0, 4)
swap([2, 3, 9, 5, 8], 0, 4) => ()
swap([2, 3, 9, 5, 8], 2, 3)
swap([2, 3, 5, 9, 8], 2, 3) => ()
partition([2, 3, 5, 9, 8], 0, 4) => 2
quicksort([2, 3, 5, 9, 8], 0, 2)
partition([2, 3, 5, 9, 8], 0, 2)
partition([2, 3, 5, 9, 8], 0, 2) => 0
quicksort([2, 3, 5, 9, 8], 0, 0)
quicksort([2, 3, 5, 9, 8], 0, 0) => ()
quicksort([2, 3, 5, 9, 8], 1, 2)
partition([2, 3, 5, 9, 8], 1, 2)
partition([2, 3, 5, 9, 8], 1, 2) => 1
quicksort([2, 3, 5, 9, 8], 1, 1)
quicksort([2, 3, 5, 9, 8], 1, 1) => ()
quicksort([2, 3, 5, 9, 8], 2, 2)
quicksort([2, 3, 5, 9, 8], 2, 2) => ()
quicksort([2, 3, 5, 9, 8], 1, 2) => ()
quicksort([2, 3, 5, 9, 8], 0, 2) => ()
quicksort([2, 3, 5, 9, 8], 3, 4)
partition([2, 3, 5, 9, 8], 3, 4)
swap([2, 3, 5, 9, 8], 3, 4)
swap([2, 3, 5, 8, 9], 3, 4) => ()
partition([2, 3, 5, 8, 9], 3, 4) => 3
quicksort([2, 3, 5, 8, 9], 3, 3)
quicksort([2, 3, 5, 8, 9], 3, 3) => ()
quicksort([2, 3, 5, 8, 9], 4, 4)
quicksort([2, 3, 5, 8, 9], 4, 4) => ()
quicksort([2, 3, 5, 8, 9], 3, 4) => ()
quicksort([2, 3, 5, 8, 9], 0, 4) => ()
 a = [var 2, 3, 5, 8, 9]
 partition = func ...
 quicksort = func ...
 swap = func ...
 x = ()
typechecked bankex.as

 Account := Account/3
 Bank := Bank/1
 Issuer := Issuer/2
 Account : Int -> Account/3
 Bank : Int -> Bank/1
 Issuer : () -> Issuer/2
 b : Bank/1
 main : async (Account/3, Account/3)
 show : (Text, Account/3) -> ()
 test : () -> async (Account/3, Account/3)
 transfer : (Account/3, Account/3, Int) -> async ()
 Bank/1 := actor {getIssuer : () -> async Issuer/2; getReserve : () -> async Account/3}
 Issuer/2 := actor {hasIssued : (like Account/3) -> async Bool}
 Account/3 := actor {getBalance : () -> async Int; isCompatible : (like Account/3) -> async Bool; join : Account/3 -> (); split : Int -> async Account/3}
test()
test() => async {?, 0}
getReserve()
getReserve() => async {?, 0}
split(10)
split(10) => async {?, 0}
split(10)
split(10) => async {?, 0}
show(reserve, {balance = Rec (Var (80)); credit = Rec ((func ...)); getBalance = Rec ((func ...)); isCompatible = Rec ((func ...)); join = Rec ((func ...)); split = Rec ((func ...))})
show(reserve, {balance = Rec (Var (80)); credit = Rec ((func ...)); getBalance = Rec ((func ...)); isCompatible = Rec ((func ...)); join = Rec ((func ...)); split = Rec ((func ...))}) => ()
show(a1, {balance = Rec (Var (10)); credit = Rec ((func ...)); getBalance = Rec ((func ...)); isCompatible = Rec ((func ...)); join = Rec ((func ...)); split = Rec ((func ...))})
show(a1, {balance = Rec (Var (10)); credit = Rec ((func ...)); getBalance = Rec ((func ...)); isCompatible = Rec ((func ...)); join = Rec ((func ...)); split = Rec ((func ...))}) => ()
show(a2, {balance = Rec (Var (10)); credit = Rec ((func ...)); getBalance = Rec ((func ...)); isCompatible = Rec ((func ...)); join = Rec ((func ...)); split = Rec ((func ...))})
show(a2, {balance = Rec (Var (10)); credit = Rec ((func ...)); getBalance = Rec ((func ...)); isCompatible = Rec ((func ...)); join = Rec ((func ...)); split = Rec ((func ...))}) => ()
transfer({balance = Rec (Var (10)); credit = Rec ((func ...)); getBalance = Rec ((func ...)); isCompatible = Rec ((func ...)); join = Rec ((func ...)); split = Rec ((func ...))}, {balance = Rec (Var (10)); credit = Rec ((func ...)); getBalance = Rec ((func ...)); isCompatible = Rec ((func ...)); join = Rec ((func ...)); split = Rec ((func ...))}, 5)
transfer({balance = Rec (Var (10)); credit = Rec ((func ...)); getBalance = Rec ((func ...)); isCompatible = Rec ((func ...)); join = Rec ((func ...)); split = Rec ((func ...))}, {balance = Rec (Var (10)); credit = Rec ((func ...)); getBalance = Rec ((func ...)); isCompatible = Rec ((func ...)); join = Rec ((func ...)); split = Rec ((func ...))}, 5) => async {?, 0}
split(5)
split(5) => async {?, 0}
join({balance = Rec (Var (10)); credit = Rec ((func ...)); getBalance = Rec ((func ...)); isCompatible = Rec ((func ...)); join = Rec ((func ...)); split = Rec ((func ...))})
credit(5)
credit(5) => ()
join({balance = Rec (Var (15)); credit = Rec ((func ...)); getBalance = Rec ((func ...)); isCompatible = Rec ((func ...)); join = Rec ((func ...)); split = Rec ((func ...))}) => ()
show(reserve, {balance = Rec (Var (80)); credit = Rec ((func ...)); getBalance = Rec ((func ...)); isCompatible = Rec ((func ...)); join = Rec ((func ...)); split = Rec ((func ...))})
show(reserve, {balance = Rec (Var (80)); credit = Rec ((func ...)); getBalance = Rec ((func ...)); isCompatible = Rec ((func ...)); join = Rec ((func ...)); split = Rec ((func ...))}) => ()
show(a1, {balance = Rec (Var (5)); credit = Rec ((func ...)); getBalance = Rec ((func ...)); isCompatible = Rec ((func ...)); join = Rec ((func ...)); split = Rec ((func ...))})
show(a1, {balance = Rec (Var (5)); credit = Rec ((func ...)); getBalance = Rec ((func ...)); isCompatible = Rec ((func ...)); join = Rec ((func ...)); split = Rec ((func ...))}) => ()
show(a2, {balance = Rec (Var (15)); credit = Rec ((func ...)); getBalance = Rec ((func ...)); isCompatible = Rec ((func ...)); join = Rec ((func ...)); split = Rec ((func ...))})
show(a2, {balance = Rec (Var (15)); credit = Rec ((func ...)); getBalance = Rec ((func ...)); isCompatible = Rec ((func ...)); join = Rec ((func ...)); split = Rec ((func ...))}) => ()
 Account = func ...
 Bank = func ...
 Issuer = func ...
 b = Bank/1
 main = async {(Account/3, Account/3), 0}
 show = func ...
 test = func ...
 transfer = func ...
typechecked counter.as

 Counter := Counter/1
 Counter : Int -> Counter/1
 c : Counter/1
 show : Int -> ()
 test : () -> ()
 Counter/1 := actor {dec : () -> (); read : () -> async Int}
test()
test() => ()
dec()
show(10)
show(10) => ()
dec() => ()
dec()
show(9)
show(9) => ()
dec() => ()
dec()
show(8)
show(8) => ()
dec() => ()
dec()
show(7)
show(7) => ()
dec() => ()
dec()
show(6)
show(6) => ()
dec() => ()
dec()
show(5)
show(5) => ()
dec() => ()
dec()
show(4)
show(4) => ()
dec() => ()
dec()
show(3)
show(3) => ()
dec() => ()
dec()
show(2)
show(2) => ()
dec() => ()
dec()
show(1)
show(1) => ()
dec() => ()
 Counter = func ...
 c = Counter/1
 show = func ...
 test = func ...
typechecked testwhile.as

 passed : Bool
 test : () -> Int
test()
test() => 0
 passed = true
 test = func ...
