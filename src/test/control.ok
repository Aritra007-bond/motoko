Interpreter:
-- Checking control.as:
type Control <: actor {testBlock : () -> (); testLoop : () -> (); testLoopWhile : () -> (); testNestedWhile : () -> (); testWhile : () -> ()}
let Control : () -> Control
-- Interpreting control.as:
-- Finished control.as:
let Control : () -> Control = func

Compiler:
compile_dec: (ClassD
  Control
  Actor
  (TupP)
  (condition
    (DecE (FuncD condition (TupP) (PrimT Bool) (LitE (BoolLit false))))
    Const
    Private
  )
  (testBlock
    (DecE
      (FuncD
        testBlock
        (TupP)
        (TupT)
        (BlockE
          (ExpD (LabelE l1 (TupT) (BlockE (ExpD (BreakE l1 (TupE))))))
          (ExpD (LabelE l2 (TupT) (BreakE l2 (TupE))))
          (ExpD
            (LabelE
              l2
              (TupT)
              (DecE
                (LetD
                  (VarP m)
                  (AnnotE
                    (BinE (LitE (IntLit 1)) AddOp (BreakE l2 (TupE)))
                    (PrimT Int)
                  )
                )
              )
            )
          )
          (LetD
            (VarP n)
            (LabelE
              l3
              (PrimT Int)
              (BlockE (ExpD (BreakE l3 (LitE (IntLit 2)))))
            )
          )
          (LetD
            (TupP (VarP x) (VarP y) (VarP z))
            (LabelE
              l3
              (TupT (PrimT Int) (PrimT Bool) (PrimT Text))
              (BreakE
                l3
                (TupE (LitE (IntLit 2)) (LitE (BoolLit true)) (LitE (TextLit )))
              )
            )
          )
        )
      )
    )
    Const
    Public
  )
  (testWhile
    (DecE
      (FuncD
        testWhile
        (TupP)
        (TupT)
        (BlockE
          (ExpD
            (LabelE
              l
              (TupT)
              (WhileE
                (CallE (VarE condition) (TupE))
                (LabelE
                  continue l
                  (TupT)
                  (BlockE
                    (ExpD
                      (IfE
                        (LitE (BoolLit true))
                        (BreakE l (TupE))
                        (BreakE continue l (TupE))
                      )
                    )
                  )
                )
              )
            )
          )
        )
      )
    )
    Const
    Public
  )
  (testLoop
    (DecE
      (FuncD
        testLoop
        (TupP)
        (TupT)
        (BlockE
          (ExpD
            (LabelE
              l
              (TupT)
              (LoopE
                (LabelE
                  continue l
                  (TupT)
                  (BlockE
                    (ExpD
                      (IfE
                        (LitE (BoolLit true))
                        (BreakE l (TupE))
                        (BreakE continue l (TupE))
                      )
                    )
                  )
                )
              )
            )
          )
        )
      )
    )
    Const
    Public
  )
  (testLoopWhile
    (DecE
      (FuncD
        testLoopWhile
        (TupP)
        (TupT)
        (BlockE
          (ExpD
            (LabelE
              l
              (TupT)
              (LoopE
                (LabelE
                  continue l
                  (TupT)
                  (BlockE
                    (ExpD
                      (IfE
                        (LitE (BoolLit true))
                        (BreakE l (TupE))
                        (BreakE continue l (TupE))
                      )
                    )
                  )
                )
                (CallE (VarE condition) (TupE))
              )
            )
          )
        )
      )
    )
    Const
    Public
  )
  (testNestedWhile
    (DecE
      (FuncD
        testNestedWhile
        (TupP)
        (TupT)
        (BlockE
          (ExpD
            (LabelE
              l
              (TupT)
              (WhileE
                (CallE (VarE condition) (TupE))
                (LabelE
                  continue l
                  (TupT)
                  (BlockE
                    (ExpD
                      (IfE
                        (LitE (BoolLit true))
                        (BreakE l (TupE))
                        (BreakE continue l (TupE))
                      )
                    )
                    (ExpD
                      (LabelE
                        m
                        (TupT)
                        (WhileE
                          (CallE (VarE condition) (TupE))
                          (LabelE
                            continue m
                            (TupT)
                            (BlockE
                              (ExpD
                                (IfE
                                  (LitE (BoolLit true))
                                  (BreakE continue l (TupE))
                                  (BreakE m (TupE))
                                )
                              )
                            )
                          )
                        )
                      )
                    )
                  )
                )
              )
            )
          )
        )
      )
    )
    Const
    Public
  )
)
(module
  (type $0 (func))
  (type $1 (func (param i32) (result i32)))
  (table $0 1 1 anyfunc)
  (memory $0 100)
  (global $0 (mut i32) (i32.const 0))
  (func $0 (type 0) (local i32) (drop))
  (start 0)
  (elem 0 (offset (i32.const 0)) 0)
)
Interpreting the .wat:
control.wat:7.33-7.39: invalid module: type mismatch: operator requires [_] but stack has []
