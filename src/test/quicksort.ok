Interpreter:
-- Checking quicksort.as:
type QS<T> <: {quicksort : (var T[], Nat, Nat) -> ()}
let QS : <T>((T, T) -> Int) -> QS<T>
let a : var Int[]
let cmpi : (Int, Int) -> Int
let qs : QS<Int>
-- Interpreting quicksort.as:
QS(func)
  <= {partition = func; quicksort = func; swap = func; trace = func}
quicksort([8, 3, 9, 5, 2], 0, 4)
  partition([8, 3, 9, 5, 2], 0, 4)
    trace([8, 3, 9, 5, 2])
      <= ()
    cmpi(8, 8)
      <= 0
    cmpi(2, 8)
      <= -6
    swap([8, 3, 9, 5, 2], 0, 4)
      <= ()
    cmpi(2, 8)
      <= -6
    cmpi(3, 8)
      <= -5
    cmpi(9, 8)
      <= 1
    cmpi(8, 8)
      <= 0
    swap([2, 3, 9, 5, 8], 2, 4)
      <= ()
    cmpi(8, 8)
      <= 0
    cmpi(9, 8)
      <= 1
    cmpi(5, 8)
      <= -3
    swap([2, 3, 8, 5, 9], 2, 3)
      <= ()
    cmpi(5, 8)
      <= -3
    cmpi(8, 8)
      <= 0
    cmpi(8, 8)
      <= 0
    <= 3
  quicksort([2, 3, 5, 8, 9], 0, 3)
    partition([2, 3, 5, 8, 9], 0, 3)
      trace([2, 3, 5, 8, 9])
        <= ()
      cmpi(2, 2)
        <= 0
      cmpi(8, 2)
        <= 6
      cmpi(5, 2)
        <= 3
      cmpi(3, 2)
        <= 1
      cmpi(2, 2)
        <= 0
      <= 0
    quicksort([2, 3, 5, 8, 9], 0, 0)
      <= ()
    quicksort([2, 3, 5, 8, 9], 1, 3)
      partition([2, 3, 5, 8, 9], 1, 3)
        trace([2, 3, 5, 8, 9])
          <= ()
        cmpi(3, 3)
          <= 0
        cmpi(8, 3)
          <= 5
        cmpi(5, 3)
          <= 2
        cmpi(3, 3)
          <= 0
        <= 1
      quicksort([2, 3, 5, 8, 9], 1, 1)
        <= ()
      quicksort([2, 3, 5, 8, 9], 2, 3)
        partition([2, 3, 5, 8, 9], 2, 3)
          trace([2, 3, 5, 8, 9])
            <= ()
          cmpi(5, 5)
            <= 0
          cmpi(8, 5)
            <= 3
          cmpi(5, 5)
            <= 0
          <= 2
        quicksort([2, 3, 5, 8, 9], 2, 2)
          <= ()
        quicksort([2, 3, 5, 8, 9], 3, 3)
          <= ()
        <= ()
      <= ()
    <= ()
  quicksort([2, 3, 5, 8, 9], 4, 4)
    <= ()
  <= ()
-- Finished quicksort.as:
let QS : <T>((T, T) -> Int) -> QS<T> = func
let a : var Int[] = [2, 3, 5, 8, 9]
let cmpi : (Int, Int) -> Int = func
let qs : QS<Int> = QS<Int>

Compiler:
compile_dec: (ClassD
  QS
  (T AnyT)
  Object
  (AnnotP (VarP cmp) (FuncT (TupT (VarT T) (VarT T)) (PrimT Int)))
  (quicksort
    (DecE
      (FuncD
        quicksort
        (TupP
          (AnnotP (VarP a) (ArrayT Var (VarT T)))
          (AnnotP (VarP lo) (PrimT Nat))
          (AnnotP (VarP hi) (PrimT Nat))
        )
        (TupT)
        (BlockE
          (ExpD
            (IfE
              (RelE (VarE lo) LtOp (VarE hi))
              (BlockE
                (LetD
                  (VarP p)
                  (CallE (VarE partition) (TupE (VarE a) (VarE lo) (VarE hi)))
                )
                (ExpD
                  (CallE (VarE quicksort) (TupE (VarE a) (VarE lo) (VarE p)))
                )
                (ExpD
                  (CallE
                    (VarE quicksort)
                    (TupE
                      (VarE a)
                      (BinE (VarE p) AddOp  (LitE (NatLit 1)))
                      (VarE hi)
                    )
                  )
                )
              )
              (TupE)
            )
          )
        )
      )
    )
    Const
    Public
  )
  (swap
    (DecE
      (FuncD
        swap
        (TupP
          (AnnotP (VarP a) (ArrayT Var (VarT T)))
          (AnnotP (VarP i) (PrimT Nat))
          (AnnotP (VarP j) (PrimT Nat))
        )
        (TupT)
        (BlockE
          (LetD (VarP temp) (IdxE (VarE a) (VarE i)))
          (ExpD (AssignE (IdxE (VarE a) (VarE i)) (IdxE (VarE a) (VarE j))))
          (ExpD (AssignE (IdxE (VarE a) (VarE j)) (VarE temp)))
        )
      )
    )
    Const
    Private
  )
  (trace
    (DecE (FuncD trace (T AnyT) (AnnotP (VarP v) (VarT T)) (TupT) (BlockE)))
    Const
    Private
  )
  (partition
    (DecE
      (FuncD
        partition
        (TupP
          (AnnotP (VarP a) (ArrayT Var (VarT T)))
          (AnnotP (VarP lo) (PrimT Nat))
          (AnnotP (VarP hi) (PrimT Nat))
        )
        (PrimT Nat)
        (BlockE
          (ExpD (CallE (VarE trace) (ArrayT Var (VarT T)) (VarE a)))
          (LetD (VarP pivot) (IdxE (VarE a) (VarE lo)))
          (VarD i (VarE lo))
          (VarD j (VarE hi))
          (ExpD
            (LoopE
              (BlockE
                (ExpD
                  (WhileE
                    (RelE
                      (CallE
                        (VarE cmp)
                        (TupE (IdxE (VarE a) (VarE i)) (VarE pivot))
                      )
                      LtOp
                      (LitE (NatLit 0))
                    )
                    (BlockE
                      (ExpD
                        (AssignE
                          (VarE i)
                          (BinE (VarE i) AddOp  (LitE (NatLit 1)))
                        )
                      )
                    )
                  )
                )
                (ExpD
                  (WhileE
                    (RelE
                      (CallE
                        (VarE cmp)
                        (TupE (IdxE (VarE a) (VarE j)) (VarE pivot))
                      )
                      GtOp
                      (LitE (NatLit 0))
                    )
                    (BlockE
                      (ExpD
                        (AssignE
                          (VarE j)
                          (BinE (VarE j) SubOp  (LitE (NatLit 1)))
                        )
                      )
                    )
                  )
                )
                (ExpD
                  (IfE (RelE (VarE i) GeOp (VarE j)) (RetE (VarE j)) (TupE))
                )
                (ExpD (CallE (VarE swap) (TupE (VarE a) (VarE i) (VarE j))))
              )
            )
          )
        )
      )
    )
    Const
    Private
  )
)
compile_exp: (CallE (VarE QS) (PrimT Int) (VarE cmpi))
compile_exp: (CallE
  (DotE (VarE qs) quicksort)
  (TupE (VarE a) (LitE (NatLit 0)) (LitE (NatLit 4)))
)
(module
  (type $0 (func (param i32 i32) (result i32)))
  (type $1 (func))
  (memory $0 100)
  (global $0 (mut i32) (i32.const 0))
  (func $0 (type 0) (local i32) (get_local 0) (get_local 1) (i32.sub))
  (func $1
    (type 1)
    (local i32 i32 i32)
    (unreachable)
    (set_local 1)
    (i32.const 20)
    (get_global 0)
    (set_local 0)
    (get_global 0)
    (i32.add)
    (set_global 0)
    (get_local 0)
    (tee_local 0)
    (get_local 0)
    (i32.const 0)
    (i32.add)
    (i32.const 8)
    (i32.store align=1)
    (tee_local 0)
    (get_local 0)
    (i32.const 4)
    (i32.add)
    (i32.const 3)
    (i32.store align=1)
    (tee_local 0)
    (get_local 0)
    (i32.const 8)
    (i32.add)
    (i32.const 9)
    (i32.store align=1)
    (tee_local 0)
    (get_local 0)
    (i32.const 12)
    (i32.add)
    (i32.const 5)
    (i32.store align=1)
    (tee_local 0)
    (get_local 0)
    (i32.const 16)
    (i32.add)
    (i32.const 2)
    (i32.store align=1)
    (set_local 2)
    (unreachable)
  )
  (start 1)
)
Interpreting the .wat:
quicksort.wat:10.5-10.18: runtime trap: unreachable executed
