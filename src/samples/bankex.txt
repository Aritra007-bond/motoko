

Typechecking bankex.as:

 Account := Account/3
 Bank := Bank/1
 Issuer := Issuer/2
 Account : Int -> Account/3
 Bank : Int -> Bank/1
 Issuer : () -> Issuer/2
 b : Bank/1
 main : async (Account/3, Account/3)
 show : (Text, Account/3) -> ()
 test : () -> async (Account/3, Account/3)
 transfer : (Account/3, Account/3, Int) -> async ()
 Bank/1 := actor {getIssuer : () -> async Issuer/2; getReserve : () -> async Account/3}
 Issuer/2 := actor {hasIssued : (like Account/3) -> async Bool}
 Account/3 := actor {getBalance : () -> async Int; isCompatible : (like Account/3) -> async Bool; join : Account/3 -> (); split : Int -> async Account/3}


Interpreting bankex.as (tracing function calls):

test()
test() => async {?, 0}
getReserve()
getReserve() => async {?, 0}
split(10)
split(10) => async {?, 0}
split(10)
split(10) => async {?, 0}
show(reserve, {balance = Rec (Var (80)); credit = Rec ((func ...)); getBalance = Rec ((func ...)); isCompatible = Rec ((func ...)); join = Rec ((func ...)); split = Rec ((func ...))})
show(reserve, {balance = Rec (Var (80)); credit = Rec ((func ...)); getBalance = Rec ((func ...)); isCompatible = Rec ((func ...)); join = Rec ((func ...)); split = Rec ((func ...))}) => ()
show(a1, {balance = Rec (Var (10)); credit = Rec ((func ...)); getBalance = Rec ((func ...)); isCompatible = Rec ((func ...)); join = Rec ((func ...)); split = Rec ((func ...))})
show(a1, {balance = Rec (Var (10)); credit = Rec ((func ...)); getBalance = Rec ((func ...)); isCompatible = Rec ((func ...)); join = Rec ((func ...)); split = Rec ((func ...))}) => ()
show(a2, {balance = Rec (Var (10)); credit = Rec ((func ...)); getBalance = Rec ((func ...)); isCompatible = Rec ((func ...)); join = Rec ((func ...)); split = Rec ((func ...))})
show(a2, {balance = Rec (Var (10)); credit = Rec ((func ...)); getBalance = Rec ((func ...)); isCompatible = Rec ((func ...)); join = Rec ((func ...)); split = Rec ((func ...))}) => ()
transfer({balance = Rec (Var (10)); credit = Rec ((func ...)); getBalance = Rec ((func ...)); isCompatible = Rec ((func ...)); join = Rec ((func ...)); split = Rec ((func ...))}, {balance = Rec (Var (10)); credit = Rec ((func ...)); getBalance = Rec ((func ...)); isCompatible = Rec ((func ...)); join = Rec ((func ...)); split = Rec ((func ...))}, 5)
transfer({balance = Rec (Var (10)); credit = Rec ((func ...)); getBalance = Rec ((func ...)); isCompatible = Rec ((func ...)); join = Rec ((func ...)); split = Rec ((func ...))}, {balance = Rec (Var (10)); credit = Rec ((func ...)); getBalance = Rec ((func ...)); isCompatible = Rec ((func ...)); join = Rec ((func ...)); split = Rec ((func ...))}, 5) => async {?, 0}
split(5)
split(5) => async {?, 0}
join({balance = Rec (Var (10)); credit = Rec ((func ...)); getBalance = Rec ((func ...)); isCompatible = Rec ((func ...)); join = Rec ((func ...)); split = Rec ((func ...))})
credit(5)
credit(5) => ()
join({balance = Rec (Var (15)); credit = Rec ((func ...)); getBalance = Rec ((func ...)); isCompatible = Rec ((func ...)); join = Rec ((func ...)); split = Rec ((func ...))}) => ()
show(reserve, {balance = Rec (Var (80)); credit = Rec ((func ...)); getBalance = Rec ((func ...)); isCompatible = Rec ((func ...)); join = Rec ((func ...)); split = Rec ((func ...))})
show(reserve, {balance = Rec (Var (80)); credit = Rec ((func ...)); getBalance = Rec ((func ...)); isCompatible = Rec ((func ...)); join = Rec ((func ...)); split = Rec ((func ...))}) => ()
show(a1, {balance = Rec (Var (5)); credit = Rec ((func ...)); getBalance = Rec ((func ...)); isCompatible = Rec ((func ...)); join = Rec ((func ...)); split = Rec ((func ...))})
show(a1, {balance = Rec (Var (5)); credit = Rec ((func ...)); getBalance = Rec ((func ...)); isCompatible = Rec ((func ...)); join = Rec ((func ...)); split = Rec ((func ...))}) => ()
show(a2, {balance = Rec (Var (15)); credit = Rec ((func ...)); getBalance = Rec ((func ...)); isCompatible = Rec ((func ...)); join = Rec ((func ...)); split = Rec ((func ...))})
show(a2, {balance = Rec (Var (15)); credit = Rec ((func ...)); getBalance = Rec ((func ...)); isCompatible = Rec ((func ...)); join = Rec ((func ...)); split = Rec ((func ...))}) => ()

Final state bankex.as:

 Account = func ...
 Bank = func ...
 Issuer = func ...
 b = Bank/1
 main = async {(Account/3, Account/3), 0}
 show = func ...
 test = func ...
 transfer = func ...

