(* Ideally the following functions would be in the `Lsp` module, but doing so
   creates a circular dependency  with the `Lsp_t` module generated by ATD.
*)

let jsonrpc_version : string = "2.0"

let notification (params : Lsp_t.notification_message_params) : Lsp_t.notification_message = Lsp_t.
  { notification_message_jsonrpc = jsonrpc_version
  ; notification_message_params = params
  }

let response_result_message (id : int) (result : Lsp_t.response_result) : Lsp_t.response_message = Lsp_t.
  { response_message_jsonrpc = jsonrpc_version
  ; response_message_id = id
  ; response_message_result = Some result
  }

(* let response_error_message (id : int) (error : Lsp_t.response_error) : Lsp_t.response_message = *)


let oc: out_channel = open_out_gen [Open_append; Open_creat] 0o666 "ls.log"
let log_to_file (lbl: string) (txt: string): unit =
    Printf.fprintf oc "[%s] %s\n" lbl txt;
    flush oc

let send (label: string) (out: string): unit =
  let cl = "Content-Length: " ^ string_of_int (String.length out) ^ "\r\n\r\n" in
  print_string cl;
  print_string out;
  flush stdout;
  log_to_file (label ^ "_length") cl;
  log_to_file label out

let send_response: string -> unit = send "response"
let send_notification: string -> unit = send "notification"

(* TODO: pass type, use a variant *)
let show_message (typ : Lsp.MessageType.t) (msg: string): unit =
  let params =
    `WindowShowMessage
      (Lsp_t.
        { window_show_message_params_type_ = typ
        ; window_show_message_params_message = msg
        }) in
  let notification = notification params in
  send_notification (Lsp_j.string_of_notification_message notification)

let position_of_pos (pos: Source.pos): Lsp_t.position = Lsp_t.
  (* The LSP spec requires zero-based positions *)
  { position_line = if pos.Source.line > 0 then pos.Source.line - 1 else 0
  ; position_character = pos.Source.column
  }

let range_of_region (at: Source.region): Lsp_t.range = Lsp_t.
  { range_start = position_of_pos at.Source.left
  ; range_end_ = position_of_pos at.Source.right
  }

let severity_of_sev : Diag.severity -> Lsp.DiagnosticSeverity.t =
  function
  | Diag.Error -> Lsp.DiagnosticSeverity.Error
  | Diag.Warning -> Lsp.DiagnosticSeverity.Warning

let diagnostics_of_message (msg: Diag.message): Lsp_t.diagnostic = Lsp_t.
  { diagnostic_range = range_of_region msg.Diag.at
  ; diagnostic_severity = Some (severity_of_sev msg.Diag.sev)
  ; diagnostic_code = None
  ; diagnostic_source = Some "ActorScript"
  ; diagnostic_message = msg.Diag.text
  ; diagnostic_relatedInformation = None
  }

let publish_diagnostics (uri: Lsp_t.document_uri) (diags: Lsp_t.diagnostic list): unit =
  let params = `PublishDiagnostics (Lsp_t.
    { publish_diagnostics_params_uri = uri
    ; publish_diagnostics_params_diagnostics = diags
    }) in
  let notification = notification params in
  send_notification (Lsp_j.string_of_notification_message notification)

let start () =
  let client_capabilities = ref None in

  let rec loop () =
    let clength = read_line () in
    log_to_file "content-length" clength;
    let cl = "Content-Length: " in
    let cll = String.length cl in
    let num =
      (int_of_string
        (String.trim
           (String.sub
              clength
              cll
              (String.length(clength) - cll - 1)))) + 2 in
    let buffer = Buffer.create num in
    Buffer.add_channel buffer stdin num;
    let raw = String.trim (Buffer.contents buffer) in
    log_to_file "raw" raw;

    let message = Lsp_j.incoming_message_of_string raw in
    let message_id = message.Lsp_t.incoming_message_id in

    (match (message_id, message.Lsp_t.incoming_message_params) with

    (* Request messages *)

    | (Some id, `Initialize params) ->
        client_capabilities := Some params.Lsp_t.initialize_params_capabilities;
        let result = `Initialize (Lsp_t.
          { initialize_result_capabilities =
              { server_capabilities_textDocumentSync = 1
              ; server_capabilities_hoverProvider = Some true
              }
          }) in
        let response = response_result_message id result in
        send_response (Lsp_j.string_of_response_message response);

    | (Some id, `TextDocumentHover params) ->
        let position = params.Lsp_t.text_document_position_params_position in
        let textDocument = params.Lsp_t.text_document_position_params_textDocument in
        let result = `TextDocumentHoverResponse (Lsp_t. {
          hover_result_contents = "hovered over: " ^ textDocument.text_document_identifier_uri
            ^ " " ^ string_of_int position.position_line
            ^ ", " ^ string_of_int position.position_character
        }) in
        let response = response_result_message id result in
        send_response (Lsp_j.string_of_response_message response);

    | (_, `TextDocumentDidSave params) ->
       let textDocumentIdent = params.Lsp_t.text_document_did_save_params_textDocument in
       let uri = textDocumentIdent.Lsp_t.text_document_identifier_uri in
       let prefix = "file://" ^ Sys.getcwd () ^ "/" in
       (match Base.String.chop_prefix ~prefix:prefix uri with
        | Some file_name -> begin
           let result = Pipeline.compile_files
             Pipeline.DfinityMode
             false
             [file_name] in
           show_message Lsp.MessageType.Info ("Compiling file: " ^ file_name);
          let msgs = match result with
            | Error msgs' -> msgs'
            | Ok (_, msgs') -> msgs' in
          Base.Option.iter !client_capabilities ~f:(fun capabilities ->
            (* TODO: determine if the client accepts diagnostics with related info *)
            (* let textDocument = capabilities.client_capabilities_textDocument in
            * let send_related_information = textDocument.publish_diagnostics.relatedInformation in *)
            let diags = List.map diagnostics_of_message msgs in
            publish_diagnostics uri diags;
          );
          end
        | None ->
           log_to_file
             "error"
             ("Failed to strip filename from: " ^ uri));

    (* Notification messages *)

    | (None, `Initialized _) ->
       show_message Lsp.MessageType.Info "Language server initialized"

    (* Unhandled messages *)

    | _ ->
      log_to_file "unhandled message" raw;
    );

    loop ()
  in loop ()
