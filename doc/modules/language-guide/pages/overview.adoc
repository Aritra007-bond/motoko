== Overview

=== Motivation and Goals

A simple, useful language for the Internet Computer (IC)

* Familiar syntax
* Safe by default
* Incorporating [line-through]*actor* _canister_ model
* Seamless integration of IC features
* Making most of present and future WebAssembly

=== Key Design Points

* Object-oriented, functional & imperative
* Objects as records of members
* `async`/`await` for sequential programming of asynchronous messaging
* Structural typing with simple generics and subtyping
* Safe arithmetic (unbounded and checked)
* Non-nullable types by default
* Garbage collected (no manual memory management)
* JavaScript-like syntax but statically typed & sane

Inspirations: Java(Script), C#, Swift, Pony, ML, Haskell

=== Semantics

* call-by-value (like Java, C, JS, ML; unlike Haskell, Nix)
* declarations are locally mutually recursive
* parametric, bounded polymorphism
* subtyping as subsumption, not coercion.
* no dynamic casts
* no inheritance

=== Implementation(s)

* implemented in OCaml (leverages `wasm` libary)
* simple reference interpreter
* less simple compiler to WebAssembly
** multipass with typed IR in each pass.
** uniform representation, unboxed arithmetic
** two-space gc or mark-compact gc, gc between messages (for now)
* polymorphism by erasure

== The language

=== Expressions

* Identifiers: +
`x`, `foo_bar`, `test'`, `List`, `Map`
* Parentheses for grouping
* Type annotations (to help type inference): +
`(42 : Int)`

=== Libraries

[source#impDebugInt, motoko]
....
  import Debug "mo:base/Debug";
  import Int "mo:base/Int";
....

(`import MyLib "src/MyLib"` imports a library from the local file system.)

=== Libraries

[source, motoko]
....
  import Debug "mo:base/Debug";
  import Int "mo:base/Int";
  import Trie "mo:base/Trie";

  type Users = Trie.Trie<Text, Nat>; // reference types

  Debug.print(Int.toText(7)); // reference functions/values
....

=== Blocks and declarations


[source.include_impDebugInt, motoko]
....
  type Delta = Nat;
  func print() {
    Debug.print(Int.toText(counter));
  };
  let d : Delta = 42;
  var counter = 1;
  counter := counter + d;
  print();
....

* Semicolon after each declaration!
* Mutually recursive
* Mutable variables marked explicitly

=== Control flow

* `do { … }`
* `if (b) …`
* `if (b) … else …`
* `switch e { case (pat1) e1; …; case _ en }`
* `while (b) …`
* `loop …`
* `loop …  while (b)`
* `for (pat in e) …`
* `return`, `return e`
* `label l …`,  `break l e`
* `throw`, `try e catch (x) { … }`

== Primitive types

=== Unbounded integers

`Int`

Inferred by default for negative literals.

Literals: `13`, `0xf4`, `-20`, `+1`, `1_000_000`

=== Unbounded naturals

`Nat`

Non-negative, trap upon underflow.

Inferred by default for non-negative literals

Literals: `13`, `0xf4`, `1_000_000`

=== Bounded numbers (trapping)

`Nat8`, `Nat16`, `Nat32`, `Nat64`, `Int8`, `Int16`, `Int32`, `Int64`

Trap on over- and underflow. Wrap-on-trap and bit-manipulating
operations available.

Needs type annotations (somewhere)

Literals: `13`, `0xf4`, `-20`, `1_000_000`

=== Floating point numbers

`Float`

IEEE 754 double precision (64 bit) semantics, normalized NaN

Inferred for fractional literals

Literals: 0, -10, `2.71`, `-0.3e+15`, `3.141_592_653_589_793_12`

=== Numeric operations

No surprises here

`- x` +
`a + b` +
`a & b` +
…

=== Characters and text

`Char`, `Text`

Unicode! No random access.

* `'x'`, `+'\u{6a}'+`, `'☃'`,
* `"boo"`, `+"foo \u{62}ar ☃"+`
* `"Concat" # "enation"`

=== Booleans

`Bool`

Literals: `true`, `false`

`a or b` +
`a and b` +
`not b` +
`if (b) e1 else e2`

== Functions

=== Function types

* Simple functions:
+
[source.no-repl, motoko]
....
Int.toText : Int -> Text
....
* multiple arguments and return values
+
[source.no-repl, motoko]
....
divRem : (Int, Int) -> (Int, Int)
....
* can be generic/polymorphic
+
[source.no-repl, motoko]
....
Option.unwrapOr : <T>(?T, default : T) -> T
....
* first-class (can be passed around, stored)
+
[source.no-repl, motoko]
....
map : <A, B>(f : A -> B, xs : [A]) -> [B]
let funcs : [<T>(T) -> T] = …
....

=== Function Declarations & Use

[source.include_impDebugInt, motoko]
....
func add(x : Int, y : Int) : Int = x + y;

func applyNTimes<T>(n : Int, x : T, f : T -> ()) {
  if (n <= 0) return;
  f(x);
  applyNTimes(n-1, x, f);
};

applyNTimes<Text>(3, "Hello!", func(x) { Debug.print(x) } );
....

* `func() { … }` short for `func() : () = { … }`
* Parametric functions
* Type instantiations may sometimes be omitted
* Anonymous functions (a.k.a. lambdas)

== Composite types

=== Tuples

`(Bool, Float, Text)`

immutable, heterogeneous, fixed size

[source#tuple, motoko]
....
let tuple = (true or false, 0.6 * 2.0, "foo" # "bar");
....

[source.include_tuple, motoko]
....
tuple.1;
....

[source.include_tuple, motoko]
....
let (_,_,t) = tuple;
t
....

=== Options

`?Text`

is either a value of that type, e.g. `?"hello"`, or `null`.


[source#display, motoko]
....
func display(x : ?Text) : Text {
  switch x {
    case (null) { "No value" };
    case (?y) { "Value: " # y };
  };
};
....

[source.include_display, motoko]
....
display(null);
....

[source.include_display, motoko]
....
display(?"Test");
....

=== Arrays (immutable)

`[Text]`

[source.include_impDebugInt, motoko]
....
let days = [ "Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun" ];
assert(days.size() == 7);
assert(days[1] == "Tue");
// days[7] will trap (fixed size)
for (d in days.vals()) { Debug.print(d) };
....

=== Arrays (mutable)

`[var Nat]`

[source, motoko]
....
let counters = [var 1, 2, 3];
assert(counters.size() == 3);
counters[1] := counters[1] + 1;
// counters[3] will trap (fixed size)
....

=== Records

`{ first : Text; last : Text; salary : var Nat }`

[source.include_impDebugInt, motoko]
....
let employee = { first = "Boris"; last = "Johnson"; var salary = 81_932 };
Debug.print(
  employee.first # " " # employee.last # " earns " #
  Int.toText(employee.salary) # " pounds."
);
employee.salary += 79_496;
....

=== Objects

`{ first : Text; last : Text; get : () -> Nat; add : Nat -> () }`

[source, motoko]
....
object self {
  public let first = "Boris";
  public let last = "Johnson";
  var salary : Nat = 81_932; // private by default
  public func get() : Nat = salary;
  public func add(bump : Nat) { salary += bump };
}
....

=== Classes


[source, motoko]
....
class Employee(fst : Text, lst : Text) {
  public let first = fst;
  public let last = lst;
  var salary : Nat = 0;
  public func get() : Nat = salary;
  public func add(bump : Nat) { salary += bump };
}
....

Classes are factories for constructing objects. +
A class introduces a type and a function (for constructing instances).

(Roughly) equivalent to:

[source.no-repl, motoko]
....
type Employee = { first : Text; last : Text; get : () -> Nat; add : Nat -> ()`
func Employee(fst : Text, lst : Text) : Employee = object ...`
....

////
=== Variants

`{ #invincible; #alive : Int; #dead }`

[source, motoko]
....
type Health = { #invincible; #alive : Nat; #dead };

func takeDamage(h : Health, p : Nat) : Health {
  switch (h) {
    case (#invincible) #invincible;
    case (#alive hp) {
      if (hp > p) (#alive (hp-p)) else #dead
    };
    case (#dead) #dead;
  }
};

takeDamage(#alive 20,50);
....
////

=== Variants
`{ #Sun; #Mon; #Tue; #Wed; #Thu; #Fri; #Sat }`

[source, motoko]
....
type Day = { #Sun; #Mon; #Tue; #Wed; #Thu; #Fri; #Sat };

func toText(d : Day) : Text {
  switch d {
     case (#Sun) "Sunday";
     case (#Mon) "Monday";
     case (#Tue) "Tuesday";
     case (#Wed) "Wednesday";
     case (#Thu) "Thursday";
     case (#Fri) "Friday";
     case (#Sat) "Saturday";
   };
};

func sort(d : Day) : { #WeekDay; #WeekEnd } {
  switch d {
    case (#Sun) #WeekEnd;
    case (#Mon) #WeekEnd;
    case _ #WeekDay;
  };
};
....

=== Recursive Types

[source#Lists, motoko]
....
type List = {
  #item : { head : Text; tail : List }; // variant with payload!
  #empty
};

func reverse(l : List) : List {
  func rev(l : List, r : List) : List {
    switch l {
      case (#empty) { r };
      case (#item { head; tail }) { // nested patterns
        rev(tail, #item {head; tail = r})
      }
    }
  };
  rev(l, #empty);
};

let l = reverse(#item { head = "A"; tail = #item { head = "B"; tail = #empty }});
....

== Packages and modules

=== Modules

[source.no-repl, motoko]
....
// the type of base/Int.mo
module {
  toText : Int -> Text;
  abs : Int -> Nat;
  // ...
}
....

types and values like objects

but restricted to _static_ content (pure, no state, …)

=== Module imports

[source, motoko]
....
import Debug "mo:base/Debug";
import Int "mo:base/Int";
....

`base` package provides basic features.

More libraries popping up!

== Platform features

=== Actor types

Like object types, but marked as `actor`:

[source#actorTypes, motoko]
....
type Receiver = actor {
  recv : Text -> async Nat
};

type Broadcast = actor {
  register : Receiver -> ();
  send : Text -> async Nat;
};
....

_sharable_ arguments and _no_ or _async_ result type.

IC "canister" ≈ Motoko "actor"

=== sharable ≈ serializable

**Sharable:**

* all primitive types
* records, tuples, arrays, variants, options +
with immutable sharable components
* `actor` types
* `shared` function type

**Not sharable:**

* mutable things
* local functions
* objects (with methods)

=== A complete actor

[source.include_actorTypes, motoko]
....
import Array "mo:base/Array";
actor {

  var r : [Receiver] = [];

  public func register(a : Receiver) {
    r := Array.append(r, [a]);
  };

  public func send(t : Text) : async Nat {
    var sum = 0;
    for (a in r.vals()) {
      sum += await a.recv(t);
    };
    return sum;
  };
}
....

a typical canister main file

=== Async/await

`async T`

asychronous future or promise

introduced by `async { … }` +
(implicit in async function declaration)

`await e` +
suspends computation pending `e`’s result

=== Actor import

[source, motoko]
....
import Broadcast "canister:Broadcast";
/* or
import Broadcast "ic:r7inp-6aaaa-aaaaa-aaabq-cai";
*/
actor Self {

  var count = 0;

  public func go() {
    Broadcast.register(Self);
  };

  public func recv(msg : Text) : async Nat {
    return count;
  }
}
....

(assumes there is a candid file describing the interface of the import)

=== Principal and caller

[source, motoko]
....
import Principal "mo:base/Principal";

actor Self {

  public shared(context) func hello() : async Text {
    let myself : Principal = Principal.fromActor(Self);
    if (context.caller == myself) {
      "Talking to yourself is the first sign of madness";
    } else {
      "Hello, nice to see you";
    };
  };

}
....


=== Errors

// breaks interpreter
[source.no-repl, motoko]
....
import Principal "mo:base/Principal";
import Error "mo:base/Error";

actor Self {

  public shared(context) func hello() : async Text {
    let myself : Principal = Principal.fromActor(Self);
    if (context.caller == myself) {
      throw Error.reject("Talking to yourself is the first sign of madness");
    } else {
      "Hello, nice to see you";
    };
  };

};

async {
  let t = try Self.hello() catch (e) { Error.message(e); }
};
....

Similar to exceptions in other languages, +
but _only_ available in async contexts, e.g. shared functions; async blocks

== Type system

////
=== Structural

[source, motoko]
....
type Health1 = { #invincible; #alive : Nat; #dead };
type Health2 = { #invincible; #alive : Nat; #dead };

let takeDamage : (Health1, Nat) -> Health1 = …;
let h : Health2 = #invincible;
let h' = takeDamage(h, 100); // works
....

Type definitions +
do not create types, +
but name existing types
////
=== Structural

[source.include_Lists, motoko]
....
/*
type List = {
  #item : { head : Text; tail : List };
  #empty
};

func reverse(l : List) : List { //... };
*/
type Stack = {
   #empty;
   #item : { tail : Stack; head : Text };
};

let stack : Stack = #empty;

let revStack = reverse(stack); // works though reverse defined on List.
....

Type definitions +
do not create types, +
but name existing types

Despite their different names, `Stack` and `List` are equivalent types.

=== Subtyping

`WeekDay <: Day`

[source, motoko]
....
type WeekDay = { #Mon; #Tue; #Wed; #Thu; #Fri };

type Day = { #Sun; #Mon; #Tue; #Wed; #Thu; #Fri; #Sat };

func toText(d : Day) : Text {
  switch d
   { case (#Sun) "Sunday";
     case (#Mon) "Monday";
     //...
   };
};

let mon : WeekDay = #Mon;
let t = toText(mon); // also works
....

`t1 <: t2`: `t1` can be used wherever `t2` is expected

[source, motoko]
=== Subtyping

`Employee <: Person`

[source, motoko]
....

type Employee = { first : Text; last : Text; var salary : Nat };
type Person = { first : Text; last : Text};

func toText(p : Person) : Text {
  p.last # "," # p.first;
};

let employee : Employee =
  { first = "Boris"; last = "Johnson"; var salary = 161_401};

let t = toText(employee); // also works
....

////
=== Subtyping

`Mortal <: Health`

[source, motoko]
....
type Health = { #invincible; #alive : Nat; #dead };
type Mortal = { #alive : Nat; #dead };

let takeDamage : (Health, Nat) -> Health = …;
let h : Mortal = #alive 1000;
let h' = takeDamage(h, 100); // also works
....

`t1 <: t2`: `t1` can be used wherever `t2` is expected
////
=== Generic types

[source, motoko]
....
type List<T> = {
  #item : { head : T; tail : List<T> };
  #empty
};

func reverse<T>(l : List<T>) : List<T> {
  func rev(l : List<T>, r : List<T>) : List<T> {
    switch l {
      case (#empty) { r };
      case (#item { head; tail }) { // a nested pattern
        rev(tail, #item {head; tail = r})
      }
    }
  };
  rev(l, #empty);
};

let s : List<Text> =
  reverse(#item { head = "A"; tail = #item { head = "B"; tail = #empty }});

let ns : List<Nat> =
  reverse(#item { head = 0; tail = #item { head = 1; tail = #empty }})
....

== Fin

=== Not covered

* Polymorphic functions with type bounds
* Classes
* Error handling (`try … catch …` & `throw …`)

== Old slides

=== Classes

Classes as functions returning objects:

....
 class Counter(init : Int) {
    private var state : Int = init;
    public func inc() { state += 1; };
    public func get() : Int { state; };
  }
....

Class instantiation as function call (no `new`):

....
let c = Counter(666);
c.inc();
let 667 = c.get();
....

=== Generic Classes

....
class Dict< K, V > (cmp : (K,K)-> Int ) {
  add(k: K, v: V) { ... };
  find(k: K) : ? V { ... };
};
....

....
let d = Dict<Int,Text> (func (i:Int, j:Int) : Int = i - j);
d.add(1,"Alice");
let ? name = d.find(1);
....

=== Language prelude

* connects internal primitives with surface syntax (types, operations)
* conversions like `intToNat32`
* side-effecting operations `debugPrintInt` (tie into execution
environment)
* utilities like `hashInt`, `clzNat32`

== Sample App

=== Implementing _Chat_

* type example
* one server actor
* multiple clients, each an instance of (actor) class Client.

=== Chat Server

....
actor Server {
  private var clients : List<Client> = null;

  private shared broadcast(message : Text) {
    var next = clients;
    loop {
      switch next {
        case null { return; }
        case (?l) { l.head.send(message); next := l.tail; };
      };
    };
  };
....

....
  public func subscribe(client : Client) : async Post {
    let cs = {head = client; var tail = clients};
    clients := ?cs;
    return broadcast;
  };
};
....

=== Example: The client class

....
type Server = actor { subscribe : Client -> async Post; };

actor class Client() = this {
  private var name : Text = "";
  public func start(n : Text , s : Server) {
    name := n;
    let _ = async {
       let post = await s.subscribe(this);
       post("hello from " # name);
       post("goodbye from " # name);
    }
  };
....

....
  public func send(msg : Text) {
    debugPrint(name # " received " # msg # "\n");
  };
};
....

=== Example: test

test

....
let bob = Client();
let alice = Client();
let charlie = Client();

bob.start("Bob", Server);
alice.start("Alice", Server);
charlie.start("Charlie", Server);
....

output

....
[nix-shell:~/motoko/guide]$ ../src/moc -r chat.mo
charlie received hello from bob
alice received hello from bob
bob received hello from bob
charlie received goodbye from bob
alice received goodbye from bob
bob received goodbye from bob
charlie received hello from alice
alice received hello from alice
bob received hello from alice
charlie received goodbye from alice
alice received goodbye from alice
bob received goodbye from alice
charlie received hello from charlie
alice received hello from charlie
bob received hello from charlie
charlie received goodbye from charlie
alice received goodbye from charlie
bob received goodbye from charlie
....
