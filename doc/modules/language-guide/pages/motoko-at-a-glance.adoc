= {proglang} at-a-glance
:proglang: Motoko
:company-id: DFINITY
:sdk-short-name: DFINITY Canister SDK
ifdef::env-github,env-browser[:outfilesuffix:.adoc]
:platform: Internet Computer platform
:IC: Internet Computer

This section provides a comprehensive overview of {proglang} features in a simplified format along with a "cheat sheet" that compares {proglang} with other languages to help you identify operations that you might know by a name other than the one used in {proglang}, 

== {proglang} motivation and goals

A simple, useful language for {company-id} and the {platform}.

* Familiar syntax
* Safe by default
* Incorporates the *canister* model
* Provides seamless integration of {company-id} and the {platform} features
* Makes the most of present and future WebAssembly

## Key design points

* Object-oriented, functional, and imperative
* Objects as records of members
* `async`/`await` for sequential programming of asynchronous messaging
* Structural typing with simple generics and subtyping
* Safe arithmetic (unbounded and checked)
* Non-nullable types by default
* JavaScript-like syntax but statically typed and sane

Inspirations: Java, JavaScript, C#, Swift, Pony, ML, Haskell

== Semantics

* call-by-value
  (like Java, C, JS, ML; unlike Haskell, Nix)
* declarations are locally mutually recursive
* parametric, bounded polymorphism
* subtyping as subsumption, not coercion
* no dynamic casts
* no inheritance

== Implementations

* implemented in OCaml (leverages `wasm` libary)
* simple reference interpreter
* less simple compiler to WebAssembly
  * multipass with typed IR in each pass.
  * uniform representation, unboxed arithmetic
  * two-space gc (for now), gc between messages
* polymorphism by erasure

== Language features

The next sections highlight {proglang} programming language features in simolified forn.

=== Expressions

* Identifiers:  
  `x`, `foo_bar`, `test'`, `List`, `Map`

* Parentheses for grouping

* Type annotations (to help type inference):  
  `(42 : Int)`

=== Blocks and declarations

```
  type Delta = Nat;
  func print() {
    Debug.print(Int.toText(counter));
  };
  let d : Delta = 42;
  var counter = 1;
  counter := counter + tmp;
  print();
```

* Semicolon after each declaration!
* Mutually recursive
* Mutable variables marked explicitly

=== Control flow

- `if (b) …`
- `if (b) … else …`
- `switch x { case (pat1) e1; …; case _ en }`
- `while (b) …`
- `loop …`
- `loop … while (b)`
- `for (pat in e) …`

////
=== Labels, break and continue

  - `label l exp`
  - `break l` (more generally, `break l exp`)
  - `continue l`

labels ensure control flow is structured (no gotos)
////

== Primitive types

=== Unbounded integers

`Int`

Inferred by default for negative literals

Literals: `13`, `0xf4`, `-20`, `+1`, `1_000_000`

=== Unbounded naturals

`Nat`

Non-negative, trap upon underflow

Inferred by default for non-negative literals

Literals: `13`, `0xf4`, `1_000_000`

=== Bounded numbers (trapping)

`Nat8`, `Nat16`, `Nat32`, `Nat64`,  
`Int8`, `Int16`, `Int32`, `Int64`

Trap on over- and underflow

Needs type annotations (somewhere)

Literals: `13`, `0xf4`, `-20`, `1_000_000`

=== Bounded numbers (wrapping)

`Word8`, `Word16`, `Word32`, `Word64`

Wrap-around on over/under-flow. Use for bit-fiddling

Needs type annotations (somewhere)

Literals: `13`, `0xf4`, `-20`, `1_000_000`

=== Floating point numbers

`Float`

IEEE 754 double precision (64 bit) semantics, normalized NaN

Inferred for fractional literals

Literals: 0, -10, `2.71`, `-0.3e+15`, `3.141_592_653_589_793_12`

=== Numeric operations

No surprises here

`- x`  
`a + b`  
`a & b`  
…

=== Characters and text

`Char`, `Text`

Unicode! No random access.

 * `'x'`, `'\u{6a}'`, `'☃'`,
 * `"boo"`, `"foo \u{62}ar ☃"`
 * `"Concat" # "enation"`

=== Booleans

`Bool`

Literals: `true`, `false`

`a or b`  
`a and b`  
`not b`  
`if (b) e1 else e2`

== Functions

=== Function types

* Simple functions:
  ```
  Int.toText : Int -> Text
  ```

* multiple arguments and return values  
  ```
  divRem : (Int, Int) -> (Int, Int)
  ```

* can be generic/polymorphic  
  ```
  Option.unwrapOr : <T>(?T, default : T) -> T
  ```

* first-class (can be passed around, stored)  
  ```
  map : <A, B>(f : A -> B, xs : [A]) -> [B]
  let funcs : [<T>(T) -> T] = …
  ```

=== Function declarations and use

```
func add(x : Int, y : Int) : Int = x + y;

func applyNTimes<T>(n : Nat, x : T, f : T -> ()) {
  if (n == 0) return;
  f(x);
  applyNTimes(n-1, x, f);
}

applyNTimes<Text>(10, "Hello!", func(x) = { Debug.print(x) } );
```

* `func() { … }` short for `func() : () = { … }`
* Parametric functions
* Type instantiations may sometimes be omitted
* Anonymous functions (a.k.a. lambdas)


== Composite types

=== Tuples

`(Bool, Float, Text)`

immutable, heterogeneous, fixed size

```
let tuple = (true, 1.2, "foo");
tuple.1 > 0.0;
let (_,_,t) = tuple;
```

=== Options

`?Text`

is either a value of that type, or `null`

```
func foo(x : ?Text) : Text {
  switch x {
    case (null) { "No value" };
    case (?y) { "Value: " # y };
  };
};
foo(null);
foo(?"Test");
```

=== Arrays (immutable)

`[Text]`

```
let days = ["Monday", "Tuesday", … ];
assert(days.len() == 7);
assert(days[1] == "Tuesday");
// days[7] will trap (fixed size)
for (d in days.vals()) { Debug.print(d) };
```

=== Arrays (mutable)

`[var Nat]`

```
let counters = [var 1, 2, 3];
assert(counters.len() == 3);
counters[1] := counters[1] + 1;
// counters[3] will trap (fixed size)
```

=== Records

`{name : Text; points : var Int}`

```
let player = { name = "Joachim";  var points = 0 };
Debug.print(
  player.name # " has " #
  Int.toText(player.points) # " points."
);
player.points += 1;
```

=== Objects

`{ get : () -> Int; add : Int -> () }`

```
object self {
  var points = 0; // private by default
  public func get() = points;
  public func add(p : Int) { points += p };
}
```

Different syntax, same type as records

=== Variants

`{ #invincible; #alive : Int; #dead }`

```
type Health = { #invincible; #alive : Nat; #dead };
func takeDamage(h : Health, p : Nat) : Health {
  switch (h) {
    case (#invincible) #invincible;
    case (#alive hp) {
      if (hp > p) (#alive (hp-p)) else #dead
    };
    case (#dead) #dead;
  }
}
```

==# Packages and modules

=== Modules

```
// the type of base/Int.mo
module {
  toText : Int -> Text;
  abs : Int -> Nat;
  …
}
```

types and values like objects

but restricted to _static_ content (pure, no state, …)

=== Module imports

```
import Debug "mo:base/Debug";
import Int "mo:base/Int";
```

`base` package provides basic features.

More libraries popping up!

==# Platform features

=== Actor types

Like object types, but marked as `actor`:

```
type Receiver = actor { recv : Text -> async Nat };
type Broadcast = actor {
  register : Receiver -> ();
  send : Text -> async Nat;
}
```

_sharable_ arguments and _no_ or _async_ result type.

“canister” ≈ “actor”

=== sharable ≈ serializable

  - all primitive types
  - records, tuples, arrays, variants, options  
    with immutable sharable components
  - `actor` types
  - `shared` function type<br/><br/>**Not sharable:**
  - mutable things
  - local functions
  - objects (with methods)


=== A complete actor

```
import Array "mo:base/Array";
actor {
  var r : [Receiver] = [];
  public func register(a : Receiver) {
    r := Array.append(r, [a]);
  };
  public func send(t : Text) : async Nat {
    var sum := 0;
    for (a in r.values()) {
      sum += await a.recv(t);
    };
    return sum;
  };
}
```

a typical canister main file

=== Async/await

`async T`

asynchronous future or promise

introduced by `async { … }`  
(implicit in async function declaration)

`await e`  
suspends computation pending `e`'s result

=== Actor import

```
import Broadcast "ic:ABCDEF23";
actor Self {
  public func go() {
    Broadcast.register(Self);
  };
  public func recv(msg : Text) : async Nat {
    …
  }
}
```

=== Principal and caller

```
actor Self {
  let myself : Principal = Principal.fromActor(Self);
  public shared(context) func hello() : async Text {
    if (context.caller == myself) {
      "Talking to yourself is the first sign of madness";
    } else {
      "Hello, nice to see you";
    };
  };
}
```

`Principal`: identity of a user or canister/actor

==# Type system

=== Structural

```
type Health1 = { #invincible; #alive : Nat; #dead };
type Health2 = { #invincible; #alive : Nat; #dead };

let takeDamage : (Health1, Nat) -> Health1 = …;
let h : Health2 = #invincible;
let h' = takeDamage(h, 100); // works
```

Type definitions  
do not create types,  
but name existing types

=== Subtyping

`Mortal <: Health`

```
type Health = { #invincible; #alive : Nat; #dead };
type Mortal = { #alive : Nat; #dead };

let takeDamage : (Health, Nat) -> Health = …;
let h : Mortal = #alive 1000;
let h' = takeDamage(h, 100); // also works
```

`t1 <: t2`: `t1` can be used wherever `t2` is expected

=== Generic types

```
type List<T> = ?{head : T; tail : List<T>};

…
let l : List<Nat> = ?{head = 0; tail = ?{head = 1 ; tail = null }};
```

== Error handling (

`try … catch …`
`throw …`

== Language comparison cheat sheet

////
=== Literals
[width="100%",options="header"]
|===
|Motoko |Ocaml |JavaScript/TypeScript
|> 3;
3 : Nat
|# 3;;
- : int = 3
|> 3
3

|> 3.141;
3.141 : Float
|# 3.141;;
- : float = 3.141
|> 3.141
3.141

|> “Hello world”;
“Hello world” : Text
|# “Hello world”;;
- : string = “Hello world”
|> “Hello world”
“Hello world”

|> ‘J’;
‘J’ : Char
|# ‘J’;;
- : char = ‘J’
|Does not have `char` literals -- use string

|> true;
true : Bool
|# true;;
- : bool = true
|> true
true

|> ();
|# ();;
- : unit = ()
|> undefined

|> (3, true, “hi”);
(3, true, “hi”) : (Nat, Bool, Text)
|# (3, true, “hi”);;
- : int * bool * string = 3, true, “hi”
|> [3, true, “hi”]
[3, true, “hi”]

|> [var 1, 2, 3];
[1, 2, 3] : [var Nat]
|# [|1; 2; 3|];;
- : int array = [|1; 2; 3|]
|> [1, 2, 3]
[1, 2, 3]

|> [1, 2, 3];
[1, 2, 3] : [Nat]
|# [1; 2; 3];;
- : int list = [1; 2; 3]
|> [1, 2, 3]
[1, 2, 3]
|===

=== Expressions

[width="100%",options="header"]
|===
|Motoko |Ocaml |JavaScript/TypeScript
|-3*(1+7)/2%3
|-3*(1+7)/2 mod 3
|-3*(1+7)/2%3

|-1.0 / 2.0 + 1.9 * x
|-1.0 /. 2.0 +. 1.9 *. x
|-1 / 2 + 1.9 * x

|a || b && c
|a or b and c
|a || b && c
|===

=== Functions

[width="100%",options="header"]
|===
|Motoko |Ocaml |JavaScript/TypeScript

|func<T1,T2,T3>(f : (T1, T2) -> T3) : T1 -> T2 -> T3 = func(x : T1) : T2 -> T3 = func(y : T2) : T3 = f(x,y)
|fun f -> fun x -> fun y -> f (x, y)
or
fun f x y -> f (x, y)
|f => x => y => f(x,y)

|func<T1, T2, T3>(f : (T1, T2) -> T3, x: T1, y : T2) : T3 = f (x,y)
|fun (f, x, y) -> f (x, y)
|([f, x, y]) => f(x,y)

|func f<T>(x:T) : T = x
|let f x = x
|f(x) { x }

|Does not have function pattern matching
func(x : Int) : Int =
  switch(x) {
    case (0) 0;
    case (n) 1;
  };
|function 0 -> 0
            | n -> 1
|
|===

=== Control Flow
if (3 > 2) “X” else “Y”
if 3 > 2 then “X” else “Y”
if (3 > 2) { “X” } else { “Y” }
import Debug “mo:base/Debug”;
if (3 > 2) Debug.print(“hello”);
if 3 > 2 then print_string “hello”
if (3 > 2) console.log(“hello”)
while (true) {
  Debug.print(“X”);
}
while true do
  print_string “X”
done
while(true) {
  console.log(“X”);
}
label L loop {
  if (x == 0) break L
  else continue L;
} while (true);
Does not have do while loops -- use recursion or while
do {
  if (x === 0) break;
  else continue;
} while (true);
import Iter “mo:base/Iter”;
for (i in Iter.range(1,10)) {
  Debug.print(“X”);
};
for i = 1 to 10 do
  print_string “X”
done
for (i = 1; i <= 10; i++) {
  console.log(“X”);
}
print_string “hello”;
print_string “world”
print_string “hello”;
print_string “world”
console.log(“hello”);
console.log(“world”);
Value Declarations
let name = expr;
let name = expr
const name = expr
let f = func<T1, T2>(x : T1) : T2 { expr };
let f x = expr
const f = x => expr
let fib = func(n : Nat) : Nat {expr};
let rec fib n = expr
const fib = n => expr
Type Declarations
type T = Int32 -> Bool
type t = int -> bool
<int is 31-bit signed int>
type t = (x: number) => boolean;
type AssocList<K,V> = List<(K,V)>
type (‘a, ‘b) assoc_list = (‘a * ‘b) list


type option<T> = ?T
type ‘a option = None | Some of ‘a
type option<T> = T?
type T = {#a : Int32; #b : U};
type U = (T, T);
type t = A of int | B of u
and u = t * t


type Complex = {#c : (Float, Float)};
func complex(x : Float, y : Float) : Complex = #c(x,y);
func coord(#c(x, y) : Complex) : (Float, Float) = (x, y);
type complex = C of float * float
let complex (x,y) = C (x,y)
let coord (C (x,y)) = (x,y)


Pattern Matching
func get_opt<T>(opt : ?T, d : T) : T {
  switch(opt) {
    case (null) d;
    case (?x) x;
  };
}
let get_opt (opt, d) =
  match opt with
    None -> d
  | Some x -> x


Does not have guards -- use if
import prelude “mo:base/Prelude”;
func fac(x : Nat) : Nat {
  switch(x) {
    case (0) 1;
    case (n) if (n>0) n * fac(n-1) else Prelude.unreachable();
  };
}
let rec fac = function
  0 -> 1
| n when n>0 -> n * fac(n-1)
| _ -> raise Hell


Does not have as pattern
let foo ((x,y) as p) = (x,p,y)


Tuples
type Foo = (Int32, Float, Text)
type foo = int * float * string
type foo = (number, number, string)
let bar = (0, 3.14, “hi”)
let bar = (0, 3.14, “hi”)
const bar = [0, 3.14, “hi”]
let x = bar.1
or
let (_, x, _) = bar
let _, x, _ = bar in x
const x = bar[1]
Records
type foo = {x : Int32; y : Float; var s : Text}
type foo = {x:int; y:float; mutable s:string}
Everything is mutable
type foo = {
  x: number; y: number;
  s: string
}
let bar = {x=0; y=3.14; var s=””}
let bar = {x=0; y=3.14; s=””}
const bar = {x:0; y:3.14; s:””}
bar.x
bar.y
bar.s
bar.x
bar.y
bar.s
bar.x
bar.y
bar.s
Does not pattern matching mutable fields
let {x=x; y=y} = bar
let {y=y} = bar
or
let {x;y} = bar
let {y} = bar
let {x=x; y=y; s=s} = bar
let {y=y} = bar
or
let {x;y;s} = bar
let {y;_} = bar


bar.s := “something”
bar.s <- “something”
bar.s = “something”
type Bar = { f: <T>T -> Int32 }
type bar = { f:’a.’a->int }
type bar = {
  f<T>(x:T): number;
}
References/Mutable variables
var r = 0;
let r = ref 0
let r = new Number(0) // object reference
or
let r = 0  // mutable variable
r
!r
or
r.contents
r
r := 1
r := 1
or
r.contents <- 1
r = 1
Does not take mutable variables
func f(x : Nat) : Nat = x
let f {contents=x} = x


r1 == r2
r1 != r2
r1 == r2
r1 != r2
r1.valueOf() === r2.valueOf()
r1 !== r2
Comparison
2 == 2
2 != 3
2 = 2
2 <> 3
2 === 2
2 !== 3
Does not have references
var r = 2;
var s = 2;
r == s
let r = ref 2
r == r
r != ref 2


Does not have generic equality
Does not have a proper generic equality
(2, r) != (2, r)
(2, r) = (2, ref 2)
(2, r) === (2, r)
Immutable and mutable Arrays
import Array “mo:base/Array”;
Array.tabulate(20, func(x:Nat):Nat = x*x)
List.init 20 (fun x -> x*x)


Array.init(20, 1.0)
Array.make 20 1.0


a[2]
Array.get a 2
or
a.(2)


a[2] := x
Array.set a 2 x
or
a.(2) <- x


for (x in a.vals()) {
  Debug.print(x)
}
List.iter print_string a


Strings
“Hello ” # “world\n”
“Hello “ ^ “world\n”


Int.toText(13)
debug_show(3.141)
string_of_int 13
string_of_float 3.141


s.len()
String.length s


for (c in s.chars()) {
  Debug.print(debug_show(c))
}
String.iter print_char s


Does not have index access
String.get s 0 or s.[0]


Class
class Counter(initValue:Nat) {
  var _value = initValue;
  public func get() : Nat {
    _value
  };
  func f(x: Nat) {};
}


class Counter {
  private _value;
  constructor(initValue) { _value = initValue }
  public get() { return _value }
  private f(x) {}
}
class Foo() = Self {
  func f() : Foo = Self
}








































































////