= Imperative control flow

Control flow comes in two flavors
- _declarative_ when the value itself guides control and the selection of the resulting value, like in `if` and `switch` expressions
- _imperative_ (or programmer designed), where control changes according to some manipulative syntax and the result value either doesn't exist or is uninteresting.

Imperative control flow often goes hand-in-hand with destructive updates (value-changing assignments) or other types of side-effects like input/output.

[[early-return]]
== Early `return` from `func`

Normally, the result of a function is the value of the last expression in its body. Sometimes the result is readily available at an earlier moment (usually due to some checked condition), and in such situations the `return <val>` construct can be used to abandon the regular control flow, and give the function a result immediately.

A special shortcut is available when the function has unit result type, and the shorter `return` is available instead of the equivalent `return ()`.

[[loops-labels]]
== Loops and labels

{proglang} provides several kinds of repetition constructs
- `for` expressions for iterationg over members of structured data
- `loop` expressions for programmatic repetition (optionally with termination condition)
- `while` loops for programmatic repetition with entry check.

Any of these can be prefixed with a `label <name>` qualifier to give the loop a symbolic name. The naming of loops is useful for imperatively changing the control flow of the _innermost_ loop with the given name:
- initiating a re-entry of the loop with `continue <name>`, or
- abandoning the loop altogether with `break <name>`.

In the following example the `for` expression loops over characters of some text and abandons iteration as soon as an exclamation sign is encountered

....
label letters for (c in someText.chars()) {
  if (c == '!') { break letters };
  ...
}
....

=== Labeled expressions

There are two other facets to `label`\s that are less mainstream, but come very handy in certain situations:
- `label`\s can be typed
- any expression can be affixed with a label and `break` allows to short circuit the expression's evaluation, providing a value.

The syntax for type-annotated labels is `label <id> : <type> <expr>`, signifying that any expression can be exited using a `break <id> <alt-expr>` construct that short-circuits evaluation of `<expr>`, and results in a value by evaluating `<alt-expr>` instead.

Judicious use of these constructs allows the programmer to focus on the primary program logic and handle exceptional case via `break`

....
let address = label exit : ?(Text, IPAddr) {
  let splitted = split('@', formInput);
  if splitted == null { break exit(null) };
  let ?(account, host) = splitted;
  if (not (parseAccount(account))) { break exit(null) };
  ...
}
....

[[repetition-loop]]
== Repetition with `loop`

The simplest way to indefinitely repeat a sequence of imperative expressions is by using a `loop` construct

....
loop { <expr1>; <expr2>; ... }
....

The loop can only be abandoned with a `return` or `break` construct. A re-entry condition can be affixed to allow a predicated remaining in the loop with `loop <body> while <remain-cond>`.

[[while-loops]]
== `while` loops with precondition

Sometimes the entry condition is predicating the execution of the loop body. For this kind of repetition the `while <enter-cond> <body>`-flavor is available

....
while (earned < need) { earned += earn() };
....

[[for-loops]]
== `for` loops for iteration

An iteration over elements of some homogeneous collection can be performed using a `for` loop. The values are drawn from an iterator and bound to the loop pattern in turn.

....
for ((model, year, price) in carsInStock.vals()) {
  inventory.value += price;
}
....

[[intro-range]]
== Using `range` with a `for` loop

The `range` function produces an iterator (of type `Iter`) with the given lower and upper bound, inclusive.

The following loop example prints the numbers `0` through `10` over its _eleven_ iterations:

....
var i = 0;
for (j in range(0, 10)) {
 printNat(j);
 assert(j == i);
 i += 1;
};
assert(i == 11);
....


More generally, the function `range` is a `class` that constructs iterators over sequences of natural numbers.  Each such iterator has type `Iter<Nat>`.

As a constructor function, `range` has a function type:

....
(lower:Nat, upper:Nat) -> Iter<Nat>
....

Where `Iter<Nat>` is an iterator object type with a `next` method that produces optional elements, each of type `?Nat`:

....
type Iter<Nat> = {next : () -> ?Nat};
....

For each invocation, `next` returns an optional element (of type
`?Nat`).

The value `null` indicates that the iteration sequence has terminated.

Until reaching `null`, each non-`null` value, of the form ``?``__n__ for some number _n_, contains the next successive element in the iteration sequence.

[[intro-revrange]]
== Using `revrange`

Like `range`, the function `revrange` is a `class` that constructs iterators (each of type `Iter`).
As a constructor function, it has a function type:

....
(upper:Nat, lower:Nat) -> Iter<Nat>
....

Unlike `range`, the `revrange` function _descends_ in its iteration sequence, from an initial _upper_ bound to a final _lower_ bound.

[[other-iterators]]
== Using iterators of specific data structures

Many built-in data structures come with pre-defined iterators. Below table lists them

.Iterators for data structures
|===
|Type |Name |Iterator |Elements |Element type

|`[T]`
|array of `T`s
|`vals`
|the array's members
|`T`

|`[T]`
|array of `T`s
|`keys`
|the array's valid indices
|`Nat`

|`[var T]`
|mutable array of `T`s
|`vals`
|the array's members
|`T`

|`[var T]`
|mutable array of `T`s
|`keys`
|the array's valid indices
|`Nat`

|`Text`
|text
|`chars`
|the text's characters
|`Char`

|`Blob`
|blob
|`bytes`
|the blob's bytes
|`Word8`
|===

User-defined data structures can define their own iterators. As long they conform with the `Iter<T>` type for some element type `T`, these behave like the built-in ones.
