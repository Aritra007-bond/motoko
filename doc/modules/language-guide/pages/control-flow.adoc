= Imperative control flow

Control flow comes in two flavors
- _declarative_ when the value itself guides control and the selection of the resulting value, like in `if` and `switch` expressions
- _imperative_ (or programmer designed), where control changes according to some manipulative syntax and the result value either doesn't exist or is uninteresting.

Imperative control flow often goes hand-in-hand with destructive updates (value-changing assignments) or other types of side-effects like input/output.

[[early-return]]
== Early `return` from `func`

Normally, the result of a function is the value of the last expression in its body. Sometimes the result is readily available at an earlier moment (usually due to some checked condition), and in such situations the `return <val>` construct can be used to abandon the regular control flow, and give the function a result immediately.


[[loops-labels]]
== Loops and labels

{proglang} provides several kinds of repetition constructs
- `for` expressions for iterationg over members of structured data
- `loop` expressions for programmatic repetition (optionally with termination condition)
- `while` loops for programmatic repetition with entry check.

Any of these can be prefixed with a `label <name>` qualifier to give the loop a symbolic name. The naming of loops is useful for imperatively changing the control flow of the _innermost_ loop with the given name:
- initiating a re-entry of the loop with `continue <name>`, or
- abandoning the loop altogether with `break <name>`.

In the following example the `for` expression loops over characters of some text and abandons iteration as soon as an exclamation sign is encountered

....
label letters for (c in someText.chars()) {
  if (c == '!') { break letters };
  ...
}
....

[[repetition-loop]]
== Repetition with `loop`

The simplest way indefinitely repeat a sequence of imperative expressions is by using a `loop` construct

....
loop { <expr1>; <expr2>; ... }
....

The loop can only be abandoned with a `return` or `break` construct. A re-entry condition can be affixed to allow a predicated remaining in the loop with `loop <body> while <remain-cond>`.

[[while-loops]]
== `while` loops

Sometimes the entry condition is predicating the execution of the loop body. For this kind of repetition the `while <enter-cond> <body>`-flavor is available

....
while (earned < need) { earned += earn() }
....

[[while-loops]]
== `for` loops for iteration



to do:

 - discuss use of `for` loops
 - discuss iterators; discuss examples of iterating an array and iterating a text value (`.keys`, `.vals`, `.chars`, `.size`, etc.)
 - discuss use of `while` loops
 - discuss use of `loop` (also w/ condition) loops

[[intro-range]]
== Using `range` with a `for` loop

The `range` function produces an iterator (of type `Iter`) with the given lower and upper bound, inclusive.

The following loop example prints the numbers `0` through `10` over its _eleven_ iterations:

....
var i = 0;
for (j in range(0, 10)) {
 printNat(j);
 assert(j == i);
 i += 1;
};
assert(i == 11);
....


More generally, the function `range` is a `class` that constructs iterators over sequences of natural numbers.  Each such iterator has type `Iter<Nat>`.

As a constructor function, `range` has a function type:

....
(lower:Nat, upper:Nat) -> Iter<Nat>
....

Where `Iter<Nat>` is an iterator object type with a `next` method that produces optional elements, each of type `?Nat`:

....
type Iter<Nat> = {next : () -> ?Nat};
....

For each invocation, `next` returns an optional element (of type
`?Nat`).

The value `null` indicates that the iteration sequence has terminated.

Until reaching `null`, each non-`null` value, of the form ``?``__n__ for some number _n_, contains the next successive element in the iteration sequence.

[[intro-revrange]]
== Using `revrange`

Like `range`, the function `revrange` is a `class` that constructs iterators (each of type `Iter`).
As a constructor function, it has a function type:

....
(upper:Nat, lower:Nat) -> Iter
....

Unlike `range`, the `revrange` function _descends_ in its iteration sequence, from an initial _upper_ bound to a final _lower_ bound.
