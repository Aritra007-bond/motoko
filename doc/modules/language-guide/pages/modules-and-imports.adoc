= Modules and imports

This section provides examples of different scenarios for using the `module` and `import` keywords.

To illustrate how these keywords are used, let's step through some sample code.

== Importing from the {proglang} base library

One of the most common import scenarios is one that you see illustrated in the examples in this guide, in the {proglang} projects in the examples repository, and in the tutorials involves importing modules from the {proglang} base library.
Importing modules from the base library enables you to use the functions defined in those modules rather than writing similar ones from scratch.

The following two lines import functions from the Array and Result modules:

[source,motoko]
----
import Array "mo:base/Array";
import Result "mo:base/Result";
----

Notice that the import statement includes the `+mo:+` prefix to identify the module as a {proglang} module and that the statement does not include the `+.mo+` file type extension.

== Importing local files

Another common approach to writing programs in {proglang} involves splitting up the source code into different modules.
For example, you might design an application to use the following model:

* a `+main.mo+` file to contain the actor and functions that change state.
* a `+types.mo+` file for all of your custom type definitions.
* a `+utils.mo+` file for functions that do work outside of the actor.

In this scenario, you might place all three files in the same directory and use a local import to make the functions available where they are needed.

For example, the `+main.mo+` contains the following lines to reference the modules in the same directory:

[source,motoko]
----
import Types "types";
import Utils "utils";
----

Because these lines import modules from the local project instead of the {proglang} library, these import statements don't use the `+mo:+` prefix.

In this example, both the `+types.mo+` and `+utils.mo+` files are in the same directory as the `+main.mo+` file.
Once again, import does not use the +`.mo+` file suffix.

== Importing from another package or directory

You can also import modules from other packages or from directories other than the local directory.

For example, the following lines import modules from a `+redraw+` package that is defined as a dependency: 

[source,bash]
----
import Render "mo:redraw/Render";
import Mono5x5 "mo:redraw/glyph/Mono5x5";
----

You can define dependencies for a project using the Vessel package manager or in the project `+dfx.json+` configuration file.

In this example, the `+Render+` module is in the default location for source code in the `+redraw+` package and the `+Mono5x5+` module is in a `+redraw+` package subdirectory called `+glyph+`.

== Importing from another canister

In addition to the examples above that import {proglang} modules, you can also import functions from canisters by using the `+canister:+` prefix in place of the `+mo:+` prefix.

For example, you might have a project that produces the following three canisters:

* BigMap
* Connectd
* LinkedUp

These three canisters are declared in the project's `+dfx.json+` configuration file and compiled by running `+dfx build+`.

You can then use the following lines to import the functions from the `+BigMap+` and `+Connectd+` canisters in the LinkedUp program:

[source,motoko]
----
import BigMap "canister:BigMap";
import Connectd "canister:connectd";
----

When importing canisters, it is important to note that the type for the imported canister corresponds to a **{proglang} actor** instead of a **{proglang} module**. 
This distinction can affect how some data structures are typed.

For the imported canister actor, types are derived from the Candid file—the _project-name_.did file—for the canister rather than from {proglang} itself.
The type used from a call to an imported canister, therefore, might differ from the {proglang} code that defines it.
For example, if the {proglang} code uses a `+Word8+` type, the derived type in the canister will replace the +Word8+` type to use a `+Nat8+` type.

These type differences are the result of the Candid-to-Motoko composition layer inherent to the canister abstraction. 
