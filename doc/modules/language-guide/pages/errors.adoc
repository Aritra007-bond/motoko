= Errors and Options =
Christoph Hegemann


== Different ways to represent errors in Motoko ==
. Option
. Result
. Asynchronous Exceptions

== Our Example API ==
Let's assume we're building an API for a Todo application and want to expose a function that lets a user mark one of their Todo's as *Done*.
To keep it simple we'll accept a `TodoId` and return an `Int` that represents how many seconds the Todo has been open.
We're also assuming we're running in our own canister so we return an async value.
If nothing would ever go wrong that would leave us with the following API:

----
func markDone(id : TodoId) : async Int
----

The full definition of all types and helpers we'll use in this document is included for reference:

[%collapsible]
====
[source,motoko]
----
include::../examples/todo-error.mo[tag=imports]
----
[%collapsible]
[source,motoko]
----
include::../examples/todo-error.mo[tag=intro]
----
====


== When things go wrong ==
We now realize that there are conditions under which marking a Todo as done fails.

* The `id` could reference a non-existing Todo
* The Todo might already be marked as done

We'll now talk about the different ways to communicate these errors in Motoko and slowly improve our solution.


== What error type to prefer ==


=== How _not_ to do things ===

One particularly easy and _bad_ way of reporting errors is through the use of a _sentinel_ value. For example, for our `markDone` function we might decide to use the value `-1` to signal that something failed. The callsite then has to check the return value against this special value and report the error. But it's way too easy to not check for that error condition and continue to work with that value in our code. This can lead to very bad non-local error states and is thus strongly discouraged.

Definition:
[source,motoko]
----
include::../examples/todo-error.mo[tag=sentinel-definition]
----
Callsite:
[source,motoko]
----
include::../examples/todo-error.mo[tag=sentinel-caller]
----

=== Prefer Option/Result over Exceptions where possible ===

Using `Option` or `Result` is the preferred way of signaling errors in Motoko.
They work in both synchronous and asynchronous contexts and make your APIs safer to use.
Exceptions should only be used to signal unexpected error states.

=== Error reporting with Option ===

A function that wants to return a value of type `A` or signal an error can return a value of type `?A` to use the `null` value to signal an error.
In our example this means having our `markDone` function return an `async ?Seconds`.

Here's what that looks like for our `markDone` function:

Definition:
[source,motoko]
----
include::../examples/todo-error.mo[tag=option-definition]
----
Callsite:
[source,motoko]
----
include::../examples/todo-error.mo[tag=option-caller]
----

The primary downside of this approach is that it flattens all possible errors into the singular `null` value.
Our callsite might be interested in why marking a todo as done has failed, but that information is lost by then, which means we can only tell the user that `"Something went wrong."`.
Returning optionals to signal errors should only be used if there is a single possible reason for the failure, and that reason can be easily deduced at the callsite.
One example of a good usecase for this is a HashMap lookup failing.

=== Error reporting with Result ===

To adress the shortcomings of using optionals to signal errors we'll now look at the `Result` type.
While options are a built-in type, the `Result` is defined as a variant type like so:

[source,motoko]
----
type Result<Ok, Err> = { #ok : Ok; #err : Err }
----

Because of the second type variable `Err` the `Result` type lets us pick a type we can use to return different errors.
So we'll define a `TodoError` type our `markDone` function will use to signal errors.

[source,motoko]
----
include::../examples/todo-error.mo[tag=todo-error]
----

This lets us now write the third version of `markDone`:

Definition:
[source,motoko]
----
include::../examples/todo-error.mo[tag=result-definition]
----
Callsite:
[source,motoko]
----
include::../examples/todo-error.mo[tag=result-caller]
----

And as we can see we can now give the user a useful error message.

== Working with Option/Result ==

Options or Results can be a very different way of thinking about errors, especially if you're coming from a language with ever-present exceptions.
In this chapter we'll look at the different ways to create, destructure, convert, and combine Options and Results in different ways.

=== Pattern matching ===

The first and most common way of working with `Option` and `Result` is to use 'pattern matching'.
If we have a value of type `?Text` we can use the 'switch' keyword to get at the potential `Text` inside:

[source,motoko]
----
include::../examples/error-examples.mo[tag=greet-optional]
----

The important thing to understand here is that Motoko does not let you access the non-optional value without also dealing with the possibility of it missing.

In the case of a `Result` we can also use pattern matching, with the difference that we also get a value in the `#err` case.

[source,motoko]
----
include::../examples/error-examples.mo[tag=greet-result]
----

=== Higher-Order functions ===

Pattern matching can become tedious and verbose, especially when dealing with multiple optional values.
The base(TODO: link base here) library exposes a collection of higher-order functions from the `Optional` and `Result` modules to improve ergonomics around error handling.

=== Converting back and forth between Option/Result ===
Sometimes you'll want to move between Options and Results.
A Hashmap lookup returns an Option on failure and that's fine, but maybe your callsite has more context and can turn that lookup failure into a meaningful Result.
At other times you don't need the additional information a Result provides and just want to convert all `#err` cases into `null`.
For these situations `base` provides the `fromOption` and `toOption` functions in the `Result` module.

== Asynchronous Exceptions ==

The last way of dealing with errors in Motoko is to use exceptions.
_But_ unlike in other languages with exceptions these can only be caught and handled at asynchronous boundaries.
This means you can `try` calling a function on another canister and it may fail, but you can't use exceptions to handle errors within the context of a single message call.

Exceptions should generally only be used to signal unexpected failures that you cannot recover from, and that you don't expect many consumers of your API to handle. If a failure should be handled by your caller you should make it explicit in your signature by returning a `Result` instead. For completeness here is the `markDone` example with exceptions:

Definition:
[source,motoko]
----
include::../examples/todo-error.mo[tag=exception-definition]
----
Callsite:
[source,motoko]
----
include::../examples/todo-error.mo[tag=exception-caller]
----