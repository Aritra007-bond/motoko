== Verifying Upgrade Compatibility

The following is a simple example of how to declare a stateful counter.

[source, motoko]
....
include::../examples/count-v0.mo[]
....

Unfortunately, when  we upgrade this counter (say with itself), it's state is lost.

|===
| version | state | status | call 
| v0 | 0 | &check; | inc()  
| v0 | 1 | &check; | inc() 
| v0 | 2 | &check; | upgrade(v0) 
| v0 | #0# | #&cross;#  | inc()  
| v0 | 1 |  |
|===

=== Marking state +stable+

In Motoko, we can declare the state to be +stable+ (across upgrades).

[source, motoko]
....
include::../examples/count-v1.mo[]
....

Now the state _is_ retained across upgrades.


|===
| version | state | status | call 
| v1 | 0 | &check; | inc()  
| v1 | 1 | &check; | inc()  
| v1 | 2 | &check; | upgrade(v1) 
| v1 | 2 | #&check;# | inc() 
| v1 | 3 | |
|===


=== Evolving the candid interface:

Let's extend the API - old clients still satisfied, new ones get
extra features (the `read` query).

[source, motoko]
....
include::../examples/count-v2.mo[]
....


|===
| version | state | status | call 
| v1 | 3 | &check; | inc() 
| v1 | 4 | &check; | upgrade(v2) 
| v2 | 4 | #&check;# | inc() 
| v2 | 5 | &check; | read() 
|===

=== Changing the stable interface

Obersvation: the counter is always positive, use a +Nat+!

Let's refactor and upgrade (shouldn't break our clients)


[source, motoko]
....
include::../examples/count-v3.mo[]
....

|===
| version | state | status | call 
| v2| 5 | &check; |  inc() 
| v2 | 6  | &check; | upgrade(v3)
| v3 | #0# | #&cross;# | inc() 
| v3 | 1 | &check; | read()
|===

BOOM!

Code updated, but counter is back to 0.

_The unthinkable has happened_: state was lost in an upgrade.

=== What gives?

The Candid API evolved just fine (to Candid subtypes) ...but the stable types did not.

An upgrade must be able to:

* consume any stable variable value from its predecessor
* or run the initializer for new stable variables.

Since `Int </: Nat`, the upgrade logic discards the saved `Int` (what if it was `-1`?) and re-runs the initializer instead.

What's worse, the upgrade silently "succeeded", resetting the counter to `0`.

=== Stable type signatures

A stable type signature looks like the insides of an Motoko actor type:

[source.no-repl, motoko]
....
include::../examples/count-v2.most[]
....

To upgrade from ``v2``'s stable types:
[source.no-repl, motoko]
....
include::../examples/count-v2.most[] 
....
to ``v3``'s stable types:
[source.no-repl, motoko]
....
include::../examples/count-v3.most[]
....

requires consuming an `Int` as a `Nat`: a _type error_.

=== Interface Evolution

[cols="1,5,5"]
|===
| version
| candid type
| stable sig

| v0
a|
[source, candid]
....
include::../examples/count-v0.did[]
....
a|
[source.no-repl, motoko]
....
include::../examples/count-v0.most[]
....

|
| +:>+ &check;
| +<<:+ &check;

| v1
a|
[source, candid]
....
include::../examples/count-v1.did[]
....
a|
[source.no-repl, motoko]
....
include::../examples/count-v1.most[]
....

|
| +:>+ &check;
| +<<:+ &check;

| v2
a|
[source, candid]
....
include::../examples/count-v2.did[]
....
a|
[source.no-repl, motoko]
....
include::../examples/count-v2.most[]
....

|
| +:>+ &check;
| +<<:+ #&cross;#

| v3
a|
[source, candid]
....
include::../examples/count-v3.did[]
....
a|
[source.no-repl, motoko]
....
include::../examples/count-v3.most[]
....
|===

=== Tooling

Motoko compiler (`moc`) now supports:

* `moc --stable-types ...` emits stable types to  `.most` file
* `moc --stable-compatible <pre> <post>` check two `.most` files for upgrade compatibility 

To upgrade from `cur.wasm` to `nxt.wasm` we need check +both+ Candid interface and stable variables are "compatible"

[source]
....
didc check nxt.did cur.did  // nxt <: cur
moc --stable-compatible cur.most nxt.most  // cur <<: nxt
....

== Metadata Sections

Motoko embeds `.did` and `.most` files as wasm _custom sections_, for use by other tools, e.g. dfx.

In future, `dfx canister upgrade` will:

* query the IC for a canister's dual interfaces, and
* check compatibility of the intalled and new binary.

=== Why are we seeing data-loss only now?

A side-effect of a revision to Candid (used for stabilizing variables):

* Previously, upgrades from `v2.wasm` to `v3.wasm` would fail and roll-back (no data loss).
* Candid revision meant upgrade would now "succeed", but _with_ data loss.

(fail safe vs silent failure)

=== The right solution

What if we really do want to change `value` to `Nat`.

Solution: introduce a new stable variable, `newValue`, initialized from the old one:

[source.no-repl, motoko]
....
include::../examples/count-v4.mo[]
....


[source.no-repl, motoko]
....
include::../examples/count-v4.most[]
....

(Or use a variant from the start...)
