== Upgrade Compatibility

The following is a simple example of how to declare a stateful counter
that can be upgraded while preserving the counter's state:

[source, motoko]
....
include::../examples/count-v0.mo[]
....

```
0 -inc()->
1 -inc()->
2 -upgrade->
0 -inc()->  // OOPS!
1
```

Every time we upgrade the counter (say with itself), it's state is lost.

=== Marking state +stable+

Let's make the state +stable+ (across upgrades).

[source, motoko]
....
include::../examples/count-v1.mo[]
....

Now the state is preserved across upgrades.

```
v1:
0 -inc()->
1 -inc()->
2 -upgrade to v1->
2 -inc()->
3 -inc()-> ...
```
=== Evolving the candid interface:

Let's extend the API - old clients still satisfied, new ones get
extra features (the +read+ query).

[source, motoko]
....
include::../examples/count-v2.mo[]
....

```
v1:
0 -inc()->
1 -inc()->
2 -upgrade to v2->
2 -inc()->
3 -read()-> ...
```

=== Changing the stable interface

Let's refactor and upgrade (shouldn't break our clients)

The counter is always positive, use a +Nat+!

[source, motoko]
....
include::../examples/count-v3.mo[]
....

```
v2:
3 -inc()->
4 -upgrade v3->
0 -inc()-> // state reverts to 0!
1 -read()-> ...
```

BOOM!

Code replaced, but counter is back to 0.

DANGER: _The unthinkable has happened_: state was lost in an upgrade.

=== What gives?

The Candid API evolved just fine (to Candid subtypes).

...but the stable API did not.

An upgrade must be able to:

* consume any stable variable value from its predecessor
* or run the initializer for new stable variables.

Since `Int </: Nat`, the upgrade logic discards the saved `Int` (what if it was `-1`?) and re-runs the initializer instead.

What's worse, the upgrade silently succeeded, resetting the counter to 0.

=== Stable signatures:

A stable variable signature looks like the insides of an {proglang} actor type:

[source.no-repl, motoko]
....
include::../examples/count-v2.most[]
....

[source.no-repl, motoko]
....
include::../examples/count-v3.most[]
....

In the last upgrade, the Candid change is safe,
but the stable variable change is unsafe.

A old `Int` cannot always be consumed as an `Int`.

=== Evolution

[cols="1,5,5"]
|===
| version
| candid type
| stable sig

| v0
a|
[source, candid]
....
include::../examples/count-v0.did[]
....
a|
[source.no-repl, motoko]
....
include::../examples/count-v0.most[]
....

|
| +:>+ &check;
| +<<:+ &check;

| v1
a|
[source, candid]
....
include::../examples/count-v1.did[]
....
a|
[source.no-repl, motoko]
....
include::../examples/count-v1.most[]
....

|
| +:>+ &check;
| +<<:+ &check;

| v2
a|
[source, candid]
....
include::../examples/count-v2.did[]
....
a|
[source.no-repl, motoko]
....
include::../examples/count-v2.most[]
....

|
| +:>+ &check;
| +<<:+ #&cross;#

| v3
a|
[source, candid]
....
include::../examples/count-v3.did[]
....
a|
[source.no-repl, motoko]
....
include::../examples/count-v3.most[]
....
|===

=== Tooling

Motoko (now) provides command-line args to emit and check stable sigatures (and candid) for upgrade compatibility (as a file and in wasm custom sections).

To upgrade from +cur.wasm+ to +nxt.wasm+ check +both+ Candid interface and stable variables are "compatible"

....
didc check nxt.did cur.did  // nxt <: cur
moc --stable-compatible cur.sig nxt.sig  // cur <<: nxt
....

Eventually, dfx should be able to query the IC
for a canister's dual interfaces and check compatibility.

=== Why are we seeing data-loss only now?

A side-effect of a revision to Candid (used for stabilizing variables):

* Previously, upgrades from count-v2 to count-v2 would fail (no data loss).
* Candid revision meant upgrade would now succeed, but with data loss.


=== The right solution

What if we really do want to change `value` to `Nat`.

Solution: introduce a new stable variable, `newValue`, initialized from the old one:

[source.no-repl, motoko]
....
include::../examples/count-v4.mo[]
....


[source.no-repl, motoko]
....
include::../examples/count-v4.most[]
....

(Or use a variant from the start...)
