<seplist(X, SEP)> ::=
    epsilon
    X
    X SEP <seplist(X, SEP)>

<seplist1(X, SEP)> ::=
    X
    X SEP <seplist(X, SEP)>

<semicolon> ::=
    ';'
    ';<eol>'

<id> ::=
    <id>

<tag> ::=
    '#' <id>

<typ_id> ::=
    <id>

<obj_sort> ::=
    'object'
    'actor'
    'module'

<func_sort_opt> ::=
    epsilon
    'shared' ['query']
    'query'

<sort_pat> ::=
    epsilon
    'shared' ['query'] [<pat_nullary>]
    'query' [<pat_nullary>]

<typ_obj> ::=
    '{' <seplist(<typ_field>, <semicolon>)> '}'

<typ_variant> ::=
    '{' '#' '}'
    '{' <seplist1(<typ_tag>, <semicolon>)> '}'

<typ_nullary> ::=
    '(' <seplist(<typ_item>, ',')> ')'
    <id> ('.' <id>)* [<typ_args>]
    '[' ['var'] <typ> ']'
    <typ_obj>
    <typ_variant>

<typ_un> ::=
    <typ_nullary>
    '?' <typ_un>

<typ_pre> ::=
    <typ_un>
    'prim' <text>
    'async' <typ_pre>
    <obj_sort> <typ_obj>

<typ> ::=
    <typ_pre>
    <func_sort_opt> ['<' <seplist(<typ_bind>, ',')> '>'] <typ_un> '->'
          <typ>

<typ_item> ::=
    <id> ':' <typ>
    <typ>

<typ_args> ::=
    '<' <seplist(<typ>, ',')> '>'

<typ_field> ::=
    ['var'] <id> ':' <typ>
    <id> ['<' <seplist(<typ_bind>, ',')> '>'] <typ_nullary>
                <return_typ>

<typ_tag> ::=
    <tag> [<return_typ_nullary>]

<typ_bind> ::=
    <id> '<:' <typ>
    <id>

<lit> ::=
    'null'
    <bool>
    <nat>
    <float>
    <char>
    <text>

<unop> ::=
    '+'
    '-'
    '^'

<binop> ::=
    '+'
    '-'
    '*'
    '/'
    '%'
    '**'
    '&'
    '|'
    '^'
    '<<'
    ' >>'
    '+>>'
    '<<>'
    '<>>'
    '#'

<relop> ::=
    '=='
    '!='
    ' < '
    '<='
    ' > '
    '>='

<unassign> ::=
    '+='
    '-='
    '^='

<binassign> ::=
    '+='
    '-='
    '*='
    '/='
    '%='
    '**-'
    '&='
    '|='
    '^='
    '<<='
    '>>='
    '+>>='
    '<<>='
    '<>>='
    '@='

<bl> ::=
    epsilon

<ob> ::=
    epsilon

<text_like> ::=
    <text>
    '(' <exp(<bl>)> ')'

<exp_block> ::=
    '{' <seplist(<dec>, <semicolon>)> '}'

<exp_nullary(B)> ::=
    '{' <seplist(<dec_var>, <semicolon>)> '}' B
    '{' <exp_field_list_unamb> '}'
    '{' <dec_list_unamb> '}'
    <id>
    <lit>
    '(' <seplist(<exp(<ob>)>, ',')> ')'
    'prim' <text>

<exp_post(B)> ::=
    <exp_nullary(B)>
    '[' ['var'] <seplist(<exp_nonvar(<ob>)>, ',')>
                  ']'
    <exp_post(<ob>)> '[' <exp(<ob>)> ']'
    <exp_post(<ob>)> '.<nat>'
    <exp_post(<ob>)> '.' <id>
    <exp_post(<ob>)> ['<' <seplist(<typ>, ',')> '>']
                  <exp_nullary(<ob>)>

<exp_un(B)> ::=
    <exp_post(B)>
    <tag>
    <tag> <exp_nullary(<ob>)>
    '?' <exp_un(<ob>)>
    <unop> <exp_un(<ob>)>
    <unassign> <exp_un(<ob>)>
    'actor' <text_like>
    'not' <exp_un(<ob>)>
    'debug_show' <exp_un(<ob>)>

<exp_bin(B)> ::=
    <exp_un(B)>
    <exp_bin(<ob>)> <binop> <exp_bin(<ob>)>
    <exp_bin(<ob>)> <relop> <exp_bin(<ob>)>
    <exp_bin(<ob>)> 'and' <exp_bin(<ob>)>
    <exp_bin(<ob>)> 'or' <exp_bin(<ob>)>
    <exp_bin(<ob>)> ':' <typ>

<exp_nondec(B)> ::=
    <exp_bin(B)>
    <exp_bin(<ob>)> ':=' <exp(<ob>)>
    <exp_bin(<ob>)> <binassign> <exp(<ob>)>
    'return'
    'return' <exp(<ob>)>
    'async' <exp(<bl>)>
    'await' <exp(<bl>)>
    'assert' <exp(<bl>)>
    'label' <id> [<return_typ_nullary>] <exp(<bl>)>
    'break' <id> [<exp_nullary(<ob>)>]
    'continue' <id>
    'debug' <exp(<bl>)>
    'if' <exp_nullary(<ob>)> <exp(<bl>)>
    'if' <exp_nullary(<ob>)> <exp(<bl>)> 'else' <exp(<bl>)>
    'try' <exp_nullary(<ob>)> 'catch' <catch>
    'throw' <exp(<bl>)>
    'switch' <exp_nullary(<ob>)> '{' <seplist(<case>,
                    <semicolon>)> '}'
    'while' <exp_nullary(<ob>)> <exp(<bl>)>
    'loop' <exp(<bl>)>
    'loop' <exp(<bl>)> 'while' <exp(<bl>)>
    'for' '(' <pat> 'in' <exp(<ob>)> ')' <exp(<bl>)>

<exp_nonvar(B)> ::=
    <exp_nondec(B)>
    <dec_nonvar>

<exp(B)> ::=
    <exp_nonvar(B)>
    <dec_var>

<case> ::=
    'case' <pat_nullary> <exp(<bl>)>

<catch> ::=
    <pat_nullary> <exp(<bl>)>

<exp_field_nonvar> ::=
    <id> '=' <exp(<ob>)>

<exp_field> ::=
    <exp_field_nonvar>
    <dec_var>

<exp_field_list_unamb> ::=
    <exp_field_nonvar>
    <exp_field_nonvar> <semicolon>
                           <seplist(<exp_field>, <semicolon>)>
    <dec_var> <semicolon> <exp_field_list_unamb>

<dec_field> ::=
    <vis> <stab> <dec>

<vis> ::=
    epsilon
    'private'
    'public'
    'system'

<stab> ::=
    epsilon
    'flexible'
    'stable'

<pat_param> ::=
    '_'
    <id>
    <lit>
    '(' <seplist(<pat_bin>, ',')> ')'

<pat_nullary> ::=
    <pat_param>
    '{' <seplist(<pat_field>, <semicolon>)> '}'

<pat_un> ::=
    <pat_nullary>
    <tag>
    <tag> <pat_nullary>
    '?' <pat_un>
    <unop> <lit>

<pat_bin> ::=
    <pat_un>
    <pat_bin> 'or' <pat_bin>
    <pat_bin> ':' <typ>

<pat> ::=
    <pat_bin>

<return_typ> ::=
    ':' <typ>

<return_typ_nullary> ::=
    ':' <typ_nullary>

<pat_field> ::=
    <id>
    <id> '=' <pat>
    <id> ':' <typ>

<dec_var> ::=
    'var' <id> [<return_typ>] '=' <exp(<ob>)>

<dec_nonvar> ::=
    'let' <pat> '=' <exp(<ob>)>
    'type' <typ_id> ['<' <seplist(<typ_bind>, ',')> '>'] '=' <typ>
    <obj_sort> [<id>] ['='] <obj_body>
    <sort_pat> 'func' [<id>] ['<' <seplist(<typ_bind>, ',')> '>']
                 <pat_param> [<return_typ>] <func_body>
    [<obj_sort>] 'class' [<typ_id>] ['<' <seplist(<typ_bind>,
                 ',')> '>'] <pat_param> [<return_typ>] <class_body>
    'ignore' <exp(<ob>)>

<dec> ::=
    <dec_var>
    <dec_nonvar>
    <exp_nondec(<ob>)>

<dec_list_unamb> ::=
    <exp_nondec(<ob>)>
    <dec_nonvar>
    <exp_nondec(<ob>)> <semicolon> <seplist(<dec>,
                     <semicolon>)>
    <dec_nonvar> <semicolon> <seplist(<dec>, <semicolon>)>
    <dec_var> <semicolon> <dec_list_unamb>

<func_body> ::=
    '=' <exp(<bl>)>
    <exp_block>

<obj_body> ::=
    '{' <seplist(<dec_field>, <semicolon>)> '}'

<class_body> ::=
    '=' [<id>] <obj_body>
    <obj_body>

<imp> ::=
    'import' [<id>] ['='] <text>

<start> ::=
    epsilon

<parse_prog> ::=
    <start> <seplist(<imp>, <semicolon>)> <seplist(<dec>,
                 <semicolon>)> <eof>

<parse_prog_interactive> ::=
    <start> <seplist(<imp>, ';')>
                             <seplist(<dec>, ';')> ';<eol>'

<import_list> ::=
    <seplist(<imp>, <semicolon>)>

<parse_module_header> ::=
    <start> <import_list> <eof>


